; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30151.0 

	TITLE	C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Distribute\CRC32.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	?GetCRC32@@YAKPBDI@Z				; GetCRC32
PUBLIC	?GetCaseCRC32@@YAKPBDI0@Z			; GetCaseCRC32
PUBLIC	?GetHFILECRC32@@YAKPAX@Z			; GetHFILECRC32
PUBLIC	?GetFileCRC32@@YAKPBD@Z				; GetFileCRC32
PUBLIC	?GetFileSize@@YAKPBD@Z				; GetFileSize
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__CreateFileMappingA@24:PROC
EXTRN	_malloc:PROC
_DATA	SEGMENT
?CRCTable@@3PAKA DD 00H					; CRCTable
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
_DATA	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\CRC32.cpp
;	COMDAT ?GetFileSize@@YAKPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?GetFileSize@@YAKPBD@Z PROC				; GetFileSize, COMDAT

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 238  : 	HANDLE hFile = CreateFile(c_szFileName,					// name of the file

  00004	6a 00		 push	 0
  00006	68 80 00 00 00	 push	 128			; 00000080H
  0000b	6a 03		 push	 3
  0000d	6a 00		 push	 0
  0000f	6a 01		 push	 1
  00011	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00016	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0001f	8b f8		 mov	 edi, eax

; 239  : 						 GENERIC_READ,					// desired access
; 240  : 						 FILE_SHARE_READ,			// share mode
; 241  : 						 NULL,						// security attributes
; 242  : 						 OPEN_EXISTING,			// creation disposition
; 243  : 						 FILE_ATTRIBUTE_NORMAL,		// flags and attr
; 244  : 						 NULL);						// template file
; 245  : 
; 246  : 	if (INVALID_HANDLE_VALUE == hFile)

  00021	83 ff ff	 cmp	 edi, -1
  00024	75 05		 jne	 SHORT $LN2@GetFileSiz

; 247  : 		return 0;

  00026	33 c0		 xor	 eax, eax
  00028	5f		 pop	 edi

; 254  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN2@GetFileSiz:
  0002b	56		 push	 esi

; 248  : 
; 249  : 	DWORD dwSize = GetFileSize(hFile, NULL);

  0002c	6a 00		 push	 0
  0002e	57		 push	 edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8

; 250  : 
; 251  : 	CloseHandle(hFile);

  00035	57		 push	 edi
  00036	8b f0		 mov	 esi, eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 252  : 
; 253  : 	return dwSize;

  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5f		 pop	 edi

; 254  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GetFileSize@@YAKPBD@Z ENDP				; GetFileSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\CRC32.cpp
;	COMDAT ?GetFileCRC32@@YAKPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?GetFileCRC32@@YAKPBD@Z PROC				; GetFileCRC32, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 217  : 	HANDLE hFile = CreateFile(c_szFileName,					// name of the file

  00004	6a 00		 push	 0
  00006	68 80 00 00 00	 push	 128			; 00000080H
  0000b	6a 03		 push	 3
  0000d	6a 00		 push	 0
  0000f	6a 01		 push	 1
  00011	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00016	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0001f	8b f8		 mov	 edi, eax

; 218  : 						 GENERIC_READ,					// desired access
; 219  : 						 FILE_SHARE_READ,			// share mode
; 220  : 						 NULL,						// security attributes
; 221  : 						 OPEN_EXISTING,			// creation disposition
; 222  : 						 FILE_ATTRIBUTE_NORMAL,		// flags and attr
; 223  : 						 NULL);						// template file
; 224  : 
; 225  : 	if (INVALID_HANDLE_VALUE == hFile)

  00021	83 ff ff	 cmp	 edi, -1
  00024	75 05		 jne	 SHORT $LN2@GetFileCRC

; 226  : 		return 0;

  00026	33 c0		 xor	 eax, eax
  00028	5f		 pop	 edi

; 234  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN2@GetFileCRC:
  0002b	56		 push	 esi

; 227  : 
; 228  : 
; 229  : 	DWORD dwRetCRC32=GetHFILECRC32(hFile);

  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?GetHFILECRC32@@YAKPAX@Z ; GetHFILECRC32
  00032	83 c4 04	 add	 esp, 4
  00035	8b f0		 mov	 esi, eax

; 230  : 
; 231  : 	CloseHandle(hFile);

  00037	57		 push	 edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 232  : 
; 233  : 	return dwRetCRC32;

  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5f		 pop	 edi

; 234  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GetFileCRC32@@YAKPBD@Z ENDP				; GetFileCRC32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\CRC32.cpp
;	COMDAT ?GetHFILECRC32@@YAKPAX@Z
_TEXT	SEGMENT
_SysInfo$ = -36						; size = 36
_hFile$ = 8						; size = 4
?GetHFILECRC32@@YAKPAX@Z PROC				; GetHFILECRC32, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 171  : 	DWORD dwRetCRC32=0;
; 172  : 
; 173  : 	DWORD dwFileSize = GetFileSize(hFile, NULL);

  00008	8b 75 08	 mov	 esi, DWORD PTR _hFile$[ebp]
  0000b	57		 push	 edi
  0000c	6a 00		 push	 0
  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  00015	8b d8		 mov	 ebx, eax

; 174  : 
; 175  : 	DWORD dataOffset=0;
; 176  : 	DWORD mapSize=dwFileSize;
; 177  : 
; 178  : 	SYSTEM_INFO SysInfo;
; 179  : 	GetSystemInfo(&SysInfo);

  00017	8d 45 dc	 lea	 eax, DWORD PTR _SysInfo$[ebp]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 180  : 
; 181  : 	DWORD dwSysGran = SysInfo.dwAllocationGranularity;
; 182  : 	DWORD dwFileMapStart = (dataOffset / dwSysGran) * dwSysGran;
; 183  : 	DWORD dwMapViewSize = (dataOffset % dwSysGran) + mapSize;
; 184  : 	//INT iViewDelta = dataOffset - dwFileMapStart;
; 185  : 
; 186  : 	HANDLE hFM = CreateFileMapping(hFile,				// handle

  00021	6a 00		 push	 0
  00023	53		 push	 ebx
  00024	6a 00		 push	 0
  00026	6a 02		 push	 2
  00028	6a 00		 push	 0
  0002a	56		 push	 esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24
  00031	8b f8		 mov	 edi, eax

; 187  : 							  NULL,					// security
; 188  : 							  PAGE_READONLY,		// flProtect
; 189  : 							  0,					// high
; 190  : 							  dataOffset + mapSize,	// low
; 191  : 							  NULL);				// name
; 192  : 	if (hFM)

  00033	85 ff		 test	 edi, edi
  00035	74 37		 je	 SHORT $LN5@GetHFILECR

; 193  : 	{
; 194  : 		LPVOID lpMapData = MapViewOfFile(hFM,

  00037	53		 push	 ebx
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 04		 push	 4
  0003e	57		 push	 edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  00045	8b f0		 mov	 esi, eax

; 195  : 									FILE_MAP_READ,
; 196  : 									0,
; 197  : 									dwFileMapStart,
; 198  : 									dwMapViewSize);
; 199  : 
; 200  : 		dwRetCRC32=GetCRC32((const char*)lpMapData, dwFileSize);

  00047	53		 push	 ebx
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  0004e	83 c4 08	 add	 esp, 8
  00051	8b d8		 mov	 ebx, eax

; 201  : 
; 202  : 
; 203  : 		if (lpMapData)

  00053	85 f6		 test	 esi, esi
  00055	74 07		 je	 SHORT $LN3@GetHFILECR

; 204  : 		{
; 205  : 
; 206  : 			UnmapViewOfFile(lpMapData);

  00057	56		 push	 esi
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4
$LN3@GetHFILECR:

; 207  : 		}
; 208  : 
; 209  : 		CloseHandle(hFM);

  0005e	57		 push	 edi
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00065	5f		 pop	 edi

; 210  : 	}
; 211  : 
; 212  : 	return dwRetCRC32;
; 213  : }

  00066	5e		 pop	 esi
  00067	8b c3		 mov	 eax, ebx
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN5@GetHFILECR:
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	33 c0		 xor	 eax, eax
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?GetHFILECRC32@@YAKPAX@Z ENDP				; GetHFILECRC32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\CRC32.cpp
;	COMDAT ?GetCaseCRC32@@YAKPBDI0@Z
_TEXT	SEGMENT
_rez$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_name$ = 16						; size = 4
?GetCaseCRC32@@YAKPBDI0@Z PROC				; GetCaseCRC32, COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 101  :     char * rez = (char *)buf;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _buf$[ebp]
  00007	56		 push	 esi

; 102  :     if (name != NULL)

  00008	8b 75 10	 mov	 esi, DWORD PTR _name$[ebp]
  0000b	57		 push	 edi
  0000c	8b fb		 mov	 edi, ebx
  0000e	85 f6		 test	 esi, esi
  00010	74 69		 je	 SHORT $LN8@GetCaseCRC

; 103  :     {
; 104  :         rez = (char *)malloc(1 + strlen(buf) + strlen(name));

  00012	8b cb		 mov	 ecx, ebx
  00014	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL56@GetCaseCRC:
  00017	8a 01		 mov	 al, BYTE PTR [ecx]
  00019	41		 inc	 ecx
  0001a	84 c0		 test	 al, al
  0001c	75 f9		 jne	 SHORT $LL56@GetCaseCRC
  0001e	2b ca		 sub	 ecx, edx
  00020	8b d6		 mov	 edx, esi
  00022	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL57@GetCaseCRC:
  00025	8a 02		 mov	 al, BYTE PTR [edx]
  00027	42		 inc	 edx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL57@GetCaseCRC
  0002c	2b d7		 sub	 edx, edi
  0002e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00031	03 c2		 add	 eax, edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _malloc
  00039	8b d0		 mov	 edx, eax
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 55 08	 mov	 DWORD PTR _rez$1$[ebp], edx
  00041	2b c6		 sub	 eax, esi
$LL12@GetCaseCRC:

; 105  :         strcpy(rez, name);

  00043	8a 0e		 mov	 cl, BYTE PTR [esi]
  00045	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00048	88 4c 30 ff	 mov	 BYTE PTR [eax+esi-1], cl
  0004c	84 c9		 test	 cl, cl
  0004e	75 f3		 jne	 SHORT $LL12@GetCaseCRC

; 106  :         strcat(rez, buf);

  00050	8b f3		 mov	 esi, ebx
$LL58@GetCaseCRC:
  00052	8a 03		 mov	 al, BYTE PTR [ebx]
  00054	43		 inc	 ebx
  00055	84 c0		 test	 al, al
  00057	75 f9		 jne	 SHORT $LL58@GetCaseCRC
  00059	2b de		 sub	 ebx, esi
  0005b	4a		 dec	 edx
  0005c	0f 1f 40 00	 npad	 4
$LL59@GetCaseCRC:
  00060	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00063	42		 inc	 edx
  00064	84 c0		 test	 al, al
  00066	75 f8		 jne	 SHORT $LL59@GetCaseCRC
  00068	8b cb		 mov	 ecx, ebx
  0006a	8b fa		 mov	 edi, edx
  0006c	c1 e9 02	 shr	 ecx, 2
  0006f	f3 a5		 rep movsd
  00071	8b cb		 mov	 ecx, ebx
  00073	83 e1 03	 and	 ecx, 3
  00076	f3 a4		 rep movsb
  00078	8b 7d 08	 mov	 edi, DWORD PTR _rez$1$[ebp]
$LN8@GetCaseCRC:

; 107  :     }
; 108  :     int lenSt = strlen(rez);
; 109  :     len = strlen(rez);

  0007b	8b f7		 mov	 esi, edi
  0007d	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL60@GetCaseCRC:
  00080	8a 06		 mov	 al, BYTE PTR [esi]
  00082	46		 inc	 esi
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL60@GetCaseCRC
  00087	2b f1		 sub	 esi, ecx

; 110  : 
; 111  :     DWORD crc = 0xffffffff;

  00089	b8 ff ff ff ff	 mov	 eax, -1

; 112  :     if (16 <= len)

  0008e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00091	0f 82 1e 02 00
	00		 jb	 $LN3@GetCaseCRC
$LL4@GetCaseCRC:

; 113  :     {
; 114  :         do
; 115  :         {
; 116  :             DO16CI(rez, 0);

  00097	8a 1f		 mov	 bl, BYTE PTR [edi]
  00099	0f be d3	 movsx	 edx, bl
  0009c	80 eb 61	 sub	 bl, 97			; 00000061H
  0009f	80 fb 19	 cmp	 bl, 25			; 00000019H
  000a2	8a 5f 01	 mov	 bl, BYTE PTR [edi+1]
  000a5	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  000a8	0f 47 ca	 cmova	 ecx, edx
  000ab	0f be d3	 movsx	 edx, bl
  000ae	33 c8		 xor	 ecx, eax
  000b0	80 eb 61	 sub	 bl, 97			; 00000061H
  000b3	0f b6 c9	 movzx	 ecx, cl
  000b6	c1 e8 08	 shr	 eax, 8
  000b9	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  000c0	80 fb 19	 cmp	 bl, 25			; 00000019H
  000c3	8a 5f 02	 mov	 bl, BYTE PTR [edi+2]
  000c6	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  000c9	0f 47 ca	 cmova	 ecx, edx
  000cc	0f be d3	 movsx	 edx, bl
  000cf	33 c8		 xor	 ecx, eax
  000d1	80 eb 61	 sub	 bl, 97			; 00000061H
  000d4	0f b6 c9	 movzx	 ecx, cl
  000d7	c1 e8 08	 shr	 eax, 8
  000da	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  000e1	80 fb 19	 cmp	 bl, 25			; 00000019H
  000e4	8a 5f 03	 mov	 bl, BYTE PTR [edi+3]
  000e7	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  000ea	0f 47 ca	 cmova	 ecx, edx
  000ed	0f be d3	 movsx	 edx, bl
  000f0	33 c8		 xor	 ecx, eax
  000f2	80 eb 61	 sub	 bl, 97			; 00000061H
  000f5	0f b6 c9	 movzx	 ecx, cl
  000f8	c1 e8 08	 shr	 eax, 8
  000fb	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00102	80 fb 19	 cmp	 bl, 25			; 00000019H
  00105	8a 5f 04	 mov	 bl, BYTE PTR [edi+4]
  00108	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  0010b	0f 47 ca	 cmova	 ecx, edx
  0010e	0f be d3	 movsx	 edx, bl
  00111	33 c8		 xor	 ecx, eax
  00113	80 eb 61	 sub	 bl, 97			; 00000061H
  00116	0f b6 c9	 movzx	 ecx, cl
  00119	c1 e8 08	 shr	 eax, 8
  0011c	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00123	80 fb 19	 cmp	 bl, 25			; 00000019H
  00126	8a 5f 05	 mov	 bl, BYTE PTR [edi+5]
  00129	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  0012c	0f 47 ca	 cmova	 ecx, edx
  0012f	0f be d3	 movsx	 edx, bl
  00132	33 c8		 xor	 ecx, eax
  00134	80 eb 61	 sub	 bl, 97			; 00000061H
  00137	0f b6 c9	 movzx	 ecx, cl
  0013a	c1 e8 08	 shr	 eax, 8
  0013d	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00144	80 fb 19	 cmp	 bl, 25			; 00000019H
  00147	8a 5f 06	 mov	 bl, BYTE PTR [edi+6]
  0014a	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  0014d	0f 47 ca	 cmova	 ecx, edx
  00150	0f be d3	 movsx	 edx, bl
  00153	33 c8		 xor	 ecx, eax
  00155	80 eb 61	 sub	 bl, 97			; 00000061H
  00158	0f b6 c9	 movzx	 ecx, cl
  0015b	c1 e8 08	 shr	 eax, 8
  0015e	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00165	80 fb 19	 cmp	 bl, 25			; 00000019H
  00168	8a 5f 07	 mov	 bl, BYTE PTR [edi+7]
  0016b	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  0016e	0f 47 ca	 cmova	 ecx, edx
  00171	0f be d3	 movsx	 edx, bl
  00174	33 c8		 xor	 ecx, eax
  00176	80 eb 61	 sub	 bl, 97			; 00000061H
  00179	0f b6 c9	 movzx	 ecx, cl
  0017c	c1 e8 08	 shr	 eax, 8
  0017f	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00186	80 fb 19	 cmp	 bl, 25			; 00000019H
  00189	8a 5f 08	 mov	 bl, BYTE PTR [edi+8]
  0018c	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  0018f	0f 47 ca	 cmova	 ecx, edx
  00192	33 c8		 xor	 ecx, eax
  00194	c1 e8 08	 shr	 eax, 8
  00197	0f b6 c9	 movzx	 ecx, cl
  0019a	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  001a1	0f be d3	 movsx	 edx, bl
  001a4	80 eb 61	 sub	 bl, 97			; 00000061H
  001a7	80 fb 19	 cmp	 bl, 25			; 00000019H
  001aa	8a 5f 09	 mov	 bl, BYTE PTR [edi+9]
  001ad	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  001b0	0f 47 ca	 cmova	 ecx, edx
  001b3	0f be d3	 movsx	 edx, bl
  001b6	33 c8		 xor	 ecx, eax
  001b8	80 eb 61	 sub	 bl, 97			; 00000061H
  001bb	0f b6 c9	 movzx	 ecx, cl
  001be	c1 e8 08	 shr	 eax, 8
  001c1	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  001c8	80 fb 19	 cmp	 bl, 25			; 00000019H
  001cb	8a 5f 0a	 mov	 bl, BYTE PTR [edi+10]
  001ce	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  001d1	0f 47 ca	 cmova	 ecx, edx
  001d4	0f be d3	 movsx	 edx, bl
  001d7	33 c8		 xor	 ecx, eax
  001d9	80 eb 61	 sub	 bl, 97			; 00000061H
  001dc	0f b6 c9	 movzx	 ecx, cl
  001df	c1 e8 08	 shr	 eax, 8
  001e2	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  001e9	80 fb 19	 cmp	 bl, 25			; 00000019H
  001ec	8a 5f 0b	 mov	 bl, BYTE PTR [edi+11]
  001ef	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  001f2	0f 47 ca	 cmova	 ecx, edx
  001f5	0f be d3	 movsx	 edx, bl
  001f8	33 c8		 xor	 ecx, eax
  001fa	80 eb 61	 sub	 bl, 97			; 00000061H
  001fd	0f b6 c9	 movzx	 ecx, cl
  00200	c1 e8 08	 shr	 eax, 8
  00203	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0020a	80 fb 19	 cmp	 bl, 25			; 00000019H
  0020d	8a 5f 0c	 mov	 bl, BYTE PTR [edi+12]
  00210	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  00213	0f 47 ca	 cmova	 ecx, edx
  00216	0f be d3	 movsx	 edx, bl
  00219	33 c8		 xor	 ecx, eax
  0021b	80 eb 61	 sub	 bl, 97			; 00000061H
  0021e	0f b6 c9	 movzx	 ecx, cl
  00221	c1 e8 08	 shr	 eax, 8
  00224	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0022b	80 fb 19	 cmp	 bl, 25			; 00000019H
  0022e	8a 5f 0d	 mov	 bl, BYTE PTR [edi+13]
  00231	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  00234	0f 47 ca	 cmova	 ecx, edx
  00237	0f be d3	 movsx	 edx, bl
  0023a	33 c8		 xor	 ecx, eax
  0023c	80 eb 61	 sub	 bl, 97			; 00000061H
  0023f	0f b6 c9	 movzx	 ecx, cl
  00242	c1 e8 08	 shr	 eax, 8
  00245	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0024c	80 fb 19	 cmp	 bl, 25			; 00000019H
  0024f	8a 5f 0e	 mov	 bl, BYTE PTR [edi+14]
  00252	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  00255	0f 47 ca	 cmova	 ecx, edx
  00258	0f be d3	 movsx	 edx, bl
  0025b	33 c8		 xor	 ecx, eax
  0025d	80 eb 61	 sub	 bl, 97			; 00000061H
  00260	0f b6 c9	 movzx	 ecx, cl
  00263	c1 e8 08	 shr	 eax, 8
  00266	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0026d	80 fb 19	 cmp	 bl, 25			; 00000019H
  00270	8a 5f 0f	 mov	 bl, BYTE PTR [edi+15]
  00273	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  00276	0f 47 ca	 cmova	 ecx, edx
  00279	0f be d3	 movsx	 edx, bl
  0027c	33 c8		 xor	 ecx, eax
  0027e	80 eb 61	 sub	 bl, 97			; 00000061H
  00281	0f b6 c9	 movzx	 ecx, cl
  00284	c1 e8 08	 shr	 eax, 8
  00287	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0028e	80 fb 19	 cmp	 bl, 25			; 00000019H
  00291	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  00294	0f 47 ca	 cmova	 ecx, edx

; 117  : 
; 118  :             rez += 16;

  00297	83 c7 10	 add	 edi, 16			; 00000010H
  0029a	33 c8		 xor	 ecx, eax
  0029c	c1 e8 08	 shr	 eax, 8
  0029f	0f b6 c9	 movzx	 ecx, cl
  002a2	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]

; 119  :             len -= 16;

  002a9	83 ee 10	 sub	 esi, 16			; 00000010H

; 120  :         } while (len >= 16);

  002ac	83 fe 10	 cmp	 esi, 16			; 00000010H
  002af	0f 83 e2 fd ff
	ff		 jae	 $LL4@GetCaseCRC
$LN3@GetCaseCRC:

; 121  :     }
; 122  : 
; 123  :     if (0 != len)

  002b5	85 f6		 test	 esi, esi
  002b7	74 2f		 je	 SHORT $LN6@GetCaseCRC
  002b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@GetCaseCRC:

; 124  :     {
; 125  :         do
; 126  :         {
; 127  :             DO1CI(rez, 0);

  002c0	8a 1f		 mov	 bl, BYTE PTR [edi]

; 128  : 
; 129  :             ++rez;

  002c2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002c5	0f be d3	 movsx	 edx, bl
  002c8	80 eb 61	 sub	 bl, 97			; 00000061H
  002cb	80 fb 19	 cmp	 bl, 25			; 00000019H
  002ce	8d 4a e0	 lea	 ecx, DWORD PTR [edx-32]
  002d1	0f 47 ca	 cmova	 ecx, edx
  002d4	33 c8		 xor	 ecx, eax
  002d6	c1 e8 08	 shr	 eax, 8
  002d9	0f b6 c9	 movzx	 ecx, cl
  002dc	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]

; 130  :             --len;

  002e3	83 ee 01	 sub	 esi, 1

; 131  :         } while (len > 0);

  002e6	75 d8		 jne	 SHORT $LL7@GetCaseCRC
$LN6@GetCaseCRC:

; 132  :     }
; 133  :     crc ^= 0xffffffff;
; 134  : 
; 135  :     return crc;

  002e8	5f		 pop	 edi
  002e9	5e		 pop	 esi
  002ea	f7 d0		 not	 eax
  002ec	5b		 pop	 ebx

; 136  : }

  002ed	5d		 pop	 ebp
  002ee	c3		 ret	 0
?GetCaseCRC32@@YAKPBDI0@Z ENDP				; GetCaseCRC32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\CRC32.cpp
;	COMDAT ?GetCRC32@@YAKPBDI@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
tv736 = 12						; size = 4
_len$ = 12						; size = 4
?GetCRC32@@YAKPBDI@Z PROC				; GetCRC32, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   :     DWORD crc = 0xffffffff;
; 61   : 
; 62   :     if (len >= 16)

  00003	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00006	83 c8 ff	 or	 eax, -1
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	83 ff 10	 cmp	 edi, 16			; 00000010H
  00010	0f 82 7c 00 00
	00		 jb	 $LN3@GetCRC32
  00016	8b cf		 mov	 ecx, edi
  00018	c1 e9 04	 shr	 ecx, 4
  0001b	53		 push	 ebx
  0001c	89 4d 0c	 mov	 DWORD PTR tv736[ebp], ecx
  0001f	56		 push	 esi
$LL4@GetCRC32:

; 63   :     {
; 64   :         do
; 65   :         {
; 66   :             DO16(buf, 0);

  00020	8d 72 02	 lea	 esi, DWORD PTR [edx+2]
  00023	bb 04 00 00 00	 mov	 ebx, 4
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL13@GetCRC32:
  00030	0f be 4e fe	 movsx	 ecx, BYTE PTR [esi-2]
  00034	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00037	33 c8		 xor	 ecx, eax
  00039	c1 e8 08	 shr	 eax, 8
  0003c	0f b6 c9	 movzx	 ecx, cl
  0003f	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00046	0f be 4e fb	 movsx	 ecx, BYTE PTR [esi-5]
  0004a	33 c8		 xor	 ecx, eax
  0004c	c1 e8 08	 shr	 eax, 8
  0004f	0f b6 c9	 movzx	 ecx, cl
  00052	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  00059	0f be 4e fc	 movsx	 ecx, BYTE PTR [esi-4]
  0005d	33 c8		 xor	 ecx, eax
  0005f	c1 e8 08	 shr	 eax, 8
  00062	0f b6 c9	 movzx	 ecx, cl
  00065	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0006c	0f be 4e fd	 movsx	 ecx, BYTE PTR [esi-3]
  00070	33 c8		 xor	 ecx, eax
  00072	c1 e8 08	 shr	 eax, 8
  00075	0f b6 c9	 movzx	 ecx, cl
  00078	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]
  0007f	83 eb 01	 sub	 ebx, 1
  00082	75 ac		 jne	 SHORT $LL13@GetCRC32

; 67   : 
; 68   :             buf += 16;

  00084	83 c2 10	 add	 edx, 16			; 00000010H

; 69   :             len -= 16;

  00087	83 ef 10	 sub	 edi, 16			; 00000010H

; 70   :         } while (len >= 16);

  0008a	83 6d 0c 01	 sub	 DWORD PTR tv736[ebp], 1
  0008e	75 90		 jne	 SHORT $LL4@GetCRC32

; 60   :     DWORD crc = 0xffffffff;
; 61   : 
; 62   :     if (len >= 16)

  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
$LN3@GetCRC32:

; 71   :     }
; 72   : 
; 73   :     if (len != 0)

  00092	85 ff		 test	 edi, edi
  00094	74 1a		 je	 SHORT $LN6@GetCRC32
$LL7@GetCRC32:

; 74   :     {
; 75   :         do
; 76   :         {
; 77   :             DO1(buf, 0);

  00096	0f be 0a	 movsx	 ecx, BYTE PTR [edx]

; 78   :             ++buf;

  00099	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0009c	33 c8		 xor	 ecx, eax
  0009e	c1 e8 08	 shr	 eax, 8
  000a1	0f b6 c9	 movzx	 ecx, cl
  000a4	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR ?CRCTable@@3PAKA[ecx*4]

; 79   :             --len;

  000ab	83 ef 01	 sub	 edi, 1

; 80   :         } while (len > 0);

  000ae	75 e6		 jne	 SHORT $LL7@GetCRC32
$LN6@GetCRC32:

; 81   :     }
; 82   : 
; 83   : 	crc ^= 0xffffffff;

  000b0	f7 d0		 not	 eax

; 84   : 	return crc;

  000b2	5f		 pop	 edi

; 85   : }

  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?GetCRC32@@YAKPBDI@Z ENDP				; GetCRC32
_TEXT	ENDS
END
