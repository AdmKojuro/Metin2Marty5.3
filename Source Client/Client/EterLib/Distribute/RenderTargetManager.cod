; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30151.0 

	TITLE	C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\Distribute\RenderTargetManager.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1_Ref_count_base@std@@UAE@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	??1?$CSingleton@VCRenderTargetManager@@@@UAE@XZ	; CSingleton<CRenderTargetManager>::~CSingleton<CRenderTargetManager>
PUBLIC	??_G?$CSingleton@VCRenderTargetManager@@@@UAEPAXI@Z ; CSingleton<CRenderTargetManager>::`scalar deleting destructor'
PUBLIC	??0CRenderTargetManager@@QAE@XZ			; CRenderTargetManager::CRenderTargetManager
PUBLIC	??1CRenderTargetManager@@UAE@XZ			; CRenderTargetManager::~CRenderTargetManager
PUBLIC	?GetRenderTarget@CRenderTargetManager@@QAE?AV?$shared_ptr@VCRenderTarget@@@std@@E@Z ; CRenderTargetManager::GetRenderTarget
PUBLIC	?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z ; CRenderTargetManager::CreateRenderTarget
PUBLIC	?CreateRenderTargetTextures@CRenderTargetManager@@QAEXXZ ; CRenderTargetManager::CreateRenderTargetTextures
PUBLIC	?ReleaseRenderTargetTextures@CRenderTargetManager@@QAEXXZ ; CRenderTargetManager::ReleaseRenderTargetTextures
PUBLIC	?Destroy@CRenderTargetManager@@QAEXXZ		; CRenderTargetManager::Destroy
PUBLIC	?DeformModels@CRenderTargetManager@@QAEXXZ	; CRenderTargetManager::DeformModels
PUBLIC	?UpdateModels@CRenderTargetManager@@QAEXXZ	; CRenderTargetManager::UpdateModels
PUBLIC	?RenderBackgrounds@CRenderTargetManager@@QAEXXZ	; CRenderTargetManager::RenderBackgrounds
PUBLIC	?RenderModels@CRenderTargetManager@@QAEXXZ	; CRenderTargetManager::RenderModels
PUBLIC	??1?$list@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >::~list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@2@PAU32@QAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::clear
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Forced_rehash
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::_Assign_grow
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >
PUBLIC	??1?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::~_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >
PUBLIC	??_GCRenderTargetManager@@UAEPAXI@Z		; CRenderTargetManager::`scalar deleting destructor'
PUBLIC	??1?$shared_ptr@VCRenderTarget@@@std@@QAE@XZ	; std::shared_ptr<CRenderTarget>::~shared_ptr<CRenderTarget>
PUBLIC	??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::emplace<unsigned char const &,std::shared_ptr<CRenderTarget> >
PUBLIC	??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
PUBLIC	??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
PUBLIC	??1?$_Ref_count_obj2@VCRenderTarget@@@std@@UAE@XZ ; std::_Ref_count_obj2<CRenderTarget>::~_Ref_count_obj2<CRenderTarget>
PUBLIC	?_Destroy@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ ; std::_Ref_count_obj2<CRenderTarget>::_Destroy
PUBLIC	?_Delete_this@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ ; std::_Ref_count_obj2<CRenderTarget>::_Delete_this
PUBLIC	??_G?$_Ref_count_obj2@VCRenderTarget@@@std@@UAEPAXI@Z ; std::_Ref_count_obj2<CRenderTarget>::`scalar deleting destructor'
PUBLIC	??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Find_last<unsigned char>
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
PUBLIC	??$_Hash_representation@E@std@@YAIABE@Z		; std::_Hash_representation<unsigned char>
PUBLIC	??$_Fnv1a_append_value@E@std@@YAIIABE@Z		; std::_Fnv1a_append_value<unsigned char>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A ; CSingleton<CRenderTargetManager>::ms_singleton
PUBLIC	??_7?$CSingleton@VCRenderTargetManager@@@@6B@	; CSingleton<CRenderTargetManager>::`vftable'
PUBLIC	??_7CRenderTargetManager@@6B@			; CRenderTargetManager::`vftable'
PUBLIC	??_7?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@	; std::_Ref_count_obj2<CRenderTarget>::`vftable'
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CRenderTargetManager@@6B@			; CRenderTargetManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRenderTargetManager@@@8		; CRenderTargetManager `RTTI Type Descriptor'
PUBLIC	??_R3CRenderTargetManager@@8			; CRenderTargetManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRenderTargetManager@@8			; CRenderTargetManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRenderTargetManager@@8		; CRenderTargetManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCRenderTargetManager@@@@8 ; CSingleton<CRenderTargetManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCRenderTargetManager@@@@@8 ; CSingleton<CRenderTargetManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCRenderTargetManager@@@@8	; CSingleton<CRenderTargetManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCRenderTargetManager@@@@8	; CSingleton<CRenderTargetManager>::`RTTI Base Class Array'
PUBLIC	??_R4?$CSingleton@VCRenderTargetManager@@@@6B@	; CSingleton<CRenderTargetManager>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@ ; std::_Ref_count_obj2<CRenderTarget>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count_obj2@VCRenderTarget@@@std@@@8 ; std::_Ref_count_obj2<CRenderTarget> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Ref_count_obj2@VCRenderTarget@@@std@@8	; std::_Ref_count_obj2<CRenderTarget>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count_obj2@VCRenderTarget@@@std@@8	; std::_Ref_count_obj2<CRenderTarget>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count_obj2@VCRenderTarget@@@std@@8 ; std::_Ref_count_obj2<CRenderTarget>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CRenderTarget@@QAE@KK@Z:PROC			; CRenderTarget::CRenderTarget
EXTRN	??1CRenderTarget@@QAE@XZ:PROC			; CRenderTarget::~CRenderTarget
EXTRN	?RenderBackground@CRenderTarget@@QBEXXZ:PROC	; CRenderTarget::RenderBackground
EXTRN	?UpdateModel@CRenderTarget@@QAEXXZ:PROC		; CRenderTarget::UpdateModel
EXTRN	?DeformModel@CRenderTarget@@QBEXXZ:PROC		; CRenderTarget::DeformModel
EXTRN	?RenderModel@CRenderTarget@@QBEXXZ:PROC		; CRenderTarget::RenderModel
EXTRN	?CreateTextures@CRenderTarget@@QBEXXZ:PROC	; CRenderTarget::CreateTextures
EXTRN	?ReleaseTextures@CRenderTarget@@QBEXXZ:PROC	; CRenderTarget::ReleaseTextures
EXTRN	??_E?$CSingleton@VCRenderTargetManager@@@@UAEPAXI@Z:PROC ; CSingleton<CRenderTargetManager>::`vector deleting destructor'
EXTRN	??_ECRenderTargetManager@@UAEPAXI@Z:PROC	; CRenderTargetManager::`vector deleting destructor'
EXTRN	??_E?$_Ref_count_obj2@VCRenderTarget@@@std@@UAEPAXI@Z:PROC ; std::_Ref_count_obj2<CRenderTarget>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_ceil:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A DD 01H DUP (?) ; CSingleton<CRenderTargetManager>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count_obj2@VCRenderTarget@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count_obj2@VCRenderTarget@@@std@@8 DD FLAT:??_R0?AV?$_Ref_count_obj2@VCRenderTarget@@@std@@@8 ; std::_Ref_count_obj2<CRenderTarget>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Ref_count_obj2@VCRenderTarget@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Ref_count_obj2@VCRenderTarget@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count_obj2@VCRenderTarget@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Ref_count_obj2@VCRenderTarget@@@std@@8 ; std::_Ref_count_obj2<CRenderTarget>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count_obj2@VCRenderTarget@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count_obj2@VCRenderTarget@@@std@@8 DD 00H	; std::_Ref_count_obj2<CRenderTarget>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Ref_count_obj2@VCRenderTarget@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count_obj2@VCRenderTarget@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Ref_count_obj2@VCRenderTarget@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count_obj2<CRenderTarget> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Ref_count_obj2@VCRenderTarget@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@ DD 00H	; std::_Ref_count_obj2<CRenderTarget>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Ref_count_obj2@VCRenderTarget@@@std@@@8
	DD	FLAT:??_R3?$_Ref_count_obj2@VCRenderTarget@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCRenderTargetManager@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCRenderTargetManager@@@@6B@ DD 00H	; CSingleton<CRenderTargetManager>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCRenderTargetManager@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCRenderTargetManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCRenderTargetManager@@@@8 ; CSingleton<CRenderTargetManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCRenderTargetManager@@@@8 DD 00H	; CSingleton<CRenderTargetManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCRenderTargetManager@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCRenderTargetManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CRenderTargetManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCRenderTargetManager@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCRenderTargetManager@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCRenderTargetManager@@@@@8 ; CSingleton<CRenderTargetManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRenderTargetManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRenderTargetManager@@8 DD FLAT:??_R0?AVCRenderTargetManager@@@8 ; CRenderTargetManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRenderTargetManager@@8
rdata$r	ENDS
;	COMDAT ??_R2CRenderTargetManager@@8
rdata$r	SEGMENT
??_R2CRenderTargetManager@@8 DD FLAT:??_R1A@?0A@EA@CRenderTargetManager@@8 ; CRenderTargetManager::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCRenderTargetManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CRenderTargetManager@@8
rdata$r	SEGMENT
??_R3CRenderTargetManager@@8 DD 00H			; CRenderTargetManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CRenderTargetManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRenderTargetManager@@@8
data$rs	SEGMENT
??_R0?AVCRenderTargetManager@@@8 DD FLAT:??_7type_info@@6B@ ; CRenderTargetManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRenderTargetManager@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CRenderTargetManager@@6B@
rdata$r	SEGMENT
??_R4CRenderTargetManager@@6B@ DD 00H			; CRenderTargetManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRenderTargetManager@@@8
	DD	FLAT:??_R3CRenderTargetManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD FLAT:??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Ref_count_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@ DD FLAT:??_R4?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@ ; std::_Ref_count_obj2<CRenderTarget>::`vftable'
	DD	FLAT:?_Destroy@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ
	DD	FLAT:?_Delete_this@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ
	DD	FLAT:??_E?$_Ref_count_obj2@VCRenderTarget@@@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_7CRenderTargetManager@@6B@
CONST	SEGMENT
??_7CRenderTargetManager@@6B@ DD FLAT:??_R4CRenderTargetManager@@6B@ ; CRenderTargetManager::`vftable'
	DD	FLAT:??_ECRenderTargetManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCRenderTargetManager@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCRenderTargetManager@@@@6B@ DD FLAT:??_R4?$CSingleton@VCRenderTargetManager@@@@6B@ ; CSingleton<CRenderTargetManager>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCRenderTargetManager@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z$0
__ehfuncinfo$??$?0ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z$0
__ehfuncinfo$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$make_shared@VCRenderTarget@@ABHABH@std@@YA?AV?$shared_ptr@VCRenderTarget@@@0@ABH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$make_shared@VCRenderTarget@@ABHABH@std@@YA?AV?$shared_ptr@VCRenderTarget@@@0@ABH0@Z$0
__ehfuncinfo$??$make_shared@VCRenderTarget@@ABHABH@std@@YA?AV?$shared_ptr@VCRenderTarget@@@0@ABH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$make_shared@VCRenderTarget@@ABHABH@std@@YA?AV?$shared_ptr@VCRenderTarget@@@0@ABH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$unordered_map@EV?$shared_ptr@VCRenderTarget@@@std@@U?$hash@E@2@U?$equal_to@E@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$unordered_map@EV?$shared_ptr@VCRenderTarget@@@std@@U?$hash@E@2@U?$equal_to@E@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$unordered_map@EV?$shared_ptr@VCRenderTarget@@@std@@U?$hash@E@2@U?$equal_to@E@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ$2
__ehfuncinfo$??0?$unordered_map@EV?$shared_ptr@VCRenderTarget@@@std@@U?$hash@E@2@U?$equal_to@E@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$unordered_map@EV?$shared_ptr@VCRenderTarget@@@std@@U?$hash@E@2@U?$equal_to@E@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@1@ABV?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@1@ABV?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@1@ABV?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@1@ABV?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@1@ABV?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z$1
__ehfuncinfo$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CRenderTargetManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CRenderTargetManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CRenderTargetManager@@QAE@XZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0CRenderTargetManager@@QAE@XZ$4
__ehfuncinfo$??0CRenderTargetManager@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CRenderTargetManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@E@std@@YAIIABE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Fnv1a_append_value@E@std@@YAIIABE@Z PROC		; std::_Fnv1a_append_value<unsigned char>, COMDAT

; 2115 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2097 :         _Val ^= static_cast<size_t>(_First[_Idx]);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00009	33 45 08	 xor	 eax, DWORD PTR __Val$[ebp]

; 2098 :         _Val *= _FNV_prime;

  0000c	69 c0 93 01 00
	01		 imul	 eax, eax, 16777619

; 2116 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2117 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
; 2118 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Fnv1a_append_value@E@std@@YAIIABE@Z ENDP		; std::_Fnv1a_append_value<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$_Hash_representation@E@std@@YAIABE@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Hash_representation@E@std@@YAIABE@Z PROC		; std::_Hash_representation<unsigned char>, COMDAT

; 2121 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2122 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

  00003	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  00006	68 c5 9d 1c 81	 push	 -2128831035		; 811c9dc5H
  0000b	e8 00 00 00 00	 call	 ??$_Fnv1a_append_value@E@std@@YAIIABE@Z ; std::_Fnv1a_append_value<unsigned char>
  00010	83 c4 08	 add	 esp, 8

; 2123 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Hash_representation@E@std@@YAIABE@Z ENDP		; std::_Hash_representation<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >, COMDAT
; _this$ = ecx

; 587  :     ~_List_node_emplace_op2() {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 588  :         if (this->_Ptr != pointer{}) {

  00004	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00007	85 f6		 test	 esi, esi
  00009	74 2a		 je	 SHORT $LN21@List_node_
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  0000b	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  0000e	85 f6		 test	 esi, esi
  00010	74 23		 je	 SHORT $LN21@List_node_

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  00012	57		 push	 edi
  00013	83 cf ff	 or	 edi, -1
  00016	8b c7		 mov	 eax, edi
  00018	f0 0f c1 46 04	 lock	  xadd	 DWORD PTR [esi+4], eax
  0001d	75 15		 jne	 SHORT $LN45@List_node_

; 1106 :             _Destroy();

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	8b ce		 mov	 ecx, esi
  00023	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  00025	f0 0f c1 7e 08	 lock	  xadd	 DWORD PTR [esi+8], edi
  0002a	4f		 dec	 edi
  0002b	75 07		 jne	 SHORT $LN45@List_node_

; 1113 :             _Delete_this();

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	8b ce		 mov	 ecx, esi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN45@List_node_:
  00034	5f		 pop	 edi
$LN21@List_node_:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 970  :         if (_Ptr) {

  00035	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	85 c0		 test	 eax, eax
  0003c	74 0b		 je	 SHORT $LN30@List_node_

; 255  :         ::operator delete(_Ptr, _Bytes);

  0003e	6a 14		 push	 20			; 00000014H
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00046	83 c4 08	 add	 esp, 8
$LN30@List_node_:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 591  :     }

  00049	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 14		 push	 20			; 00000014H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 971  :             _Al.deallocate(_Ptr, 1);
; 972  :         }
; 973  :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
__Hashval$ = 16						; size = 4
??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z PROC ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Find_last<unsigned char>, COMDAT
; _this$ = ecx

; 1497 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1498 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1499 :         const size_type _Bucket = _Hashval & _Mask;

  00003	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]

; 1500 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

  00006	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00009	23 55 10	 and	 edx, DWORD PTR __Hashval$[ebp]

; 1501 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	8d 14 d0	 lea	 edx, DWORD PTR [eax+edx*8]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 1502 :         if (_Where == _End) {

  00015	3b c1		 cmp	 eax, ecx
  00017	75 10		 jne	 SHORT $LN5@Find_last

; 1503 :             return {_End, _Nodeptr{}};

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	89 08		 mov	 DWORD PTR [eax], ecx
  0001e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1524 :         }
; 1525 :     }

  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Find_last:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef

; 84   :         return _Left == _Right;

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1506 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

  0002c	8b 12		 mov	 edx, DWORD PTR [edx]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef

; 84   :         return _Left == _Right;

  0002e	8a 09		 mov	 cl, BYTE PTR [ecx]
  00030	3a 48 08	 cmp	 cl, BYTE PTR [eax+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1509 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

  00033	74 0c		 je	 SHORT $LN15@Find_last
$LL2@Find_last:

; 1517 :             }
; 1518 : 
; 1519 :             if (_Where == _Bucket_lo) {

  00035	3b c2		 cmp	 eax, edx
  00037	74 18		 je	 SHORT $LN16@Find_last

; 1521 :             }
; 1522 : 
; 1523 :             _Where = _Where->_Prev;

  00039	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef

; 84   :         return _Left == _Right;

  0003c	3a 48 08	 cmp	 cl, BYTE PTR [eax+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1509 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

  0003f	75 f4		 jne	 SHORT $LL2@Find_last
$LN15@Find_last:

; 1510 :                 if constexpr (!_Traits::_Standard) {
; 1511 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1512 :                         return {_Where->_Next, _Nodeptr{}};
; 1513 :                     }
; 1514 :                 }
; 1515 : 
; 1516 :                 return {_Where->_Next, _Where};

  00041	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00049	8b c2		 mov	 eax, edx
  0004b	89 0a		 mov	 DWORD PTR [edx], ecx

; 1524 :         }
; 1525 :     }

  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN16@Find_last:

; 1520 :                 return {_Where, _Nodeptr{}};

  00051	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00054	89 01		 mov	 DWORD PTR [ecx], eax
  00056	8b c1		 mov	 eax, ecx
  00058	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1524 :         }
; 1525 :     }

  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Find_last<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$_Ref_count_obj2@VCRenderTarget@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Ref_count_obj2@VCRenderTarget@@@std@@UAEPAXI@Z PROC ; std::_Ref_count_obj2<CRenderTarget>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@
  00010	74 0b		 je	 SHORT $LN4@scalar
  00012	6a 30		 push	 48			; 00000030H
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$_Ref_count_obj2@VCRenderTarget@@@std@@UAEPAXI@Z ENDP ; std::_Ref_count_obj2<CRenderTarget>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Delete_this@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ PROC ; std::_Ref_count_obj2<CRenderTarget>::_Delete_this, COMDAT
; _this$ = ecx

; 2036 :         delete this;

  00000	85 c9		 test	 ecx, ecx
  00002	74 07		 je	 SHORT $LN3@Delete_thi
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	6a 01		 push	 1
  00008	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Delete_thi:

; 2037 :     }

  0000b	c3		 ret	 0
?_Delete_this@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ ENDP ; std::_Ref_count_obj2<CRenderTarget>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ?_Destroy@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Destroy@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ PROC ; std::_Ref_count_obj2<CRenderTarget>::_Destroy, COMDAT
; _this$ = ecx

; 2032 :         _Destroy_in_place(_Storage._Value);

  00000	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00003	e9 00 00 00 00	 jmp	 ??1CRenderTarget@@QAE@XZ ; CRenderTarget::~CRenderTarget
?_Destroy@?$_Ref_count_obj2@VCRenderTarget@@@std@@EAEXXZ ENDP ; std::_Ref_count_obj2<CRenderTarget>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ??1?$_Ref_count_obj2@VCRenderTarget@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$_Ref_count_obj2@VCRenderTarget@@@std@@UAE@XZ PROC	; std::_Ref_count_obj2<CRenderTarget>::~_Ref_count_obj2<CRenderTarget>, COMDAT
; _this$ = ecx

; 2018 :     virtual ~_Ref_count_obj2() noexcept override { // TRANSITION, should be non-virtual

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@

; 2019 :         // nothing to do, _Storage._Value was already destroyed in _Destroy
; 2020 : 
; 2021 :         // N4849 [class.dtor]/7:
; 2022 :         // "A defaulted destructor for a class X is defined as deleted if:
; 2023 :         // X is a union-like class that has a variant member with a non-trivial destructor"
; 2024 :     }

  00006	c3		 ret	 0
??1?$_Ref_count_obj2@VCRenderTarget@@@std@@UAE@XZ ENDP	; std::_Ref_count_obj2<CRenderTarget>::~_Ref_count_obj2<CRenderTarget>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >, COMDAT

; 1758 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1418 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx

; 1759 :     // copy _Val throughout raw [_First, _Last)
; 1760 :     _Adl_verify_range(_First, _Last);
; 1761 :     auto _UFirst      = _Get_unwrapped(_First);
; 1762 :     const auto _ULast = _Get_unwrapped(_Last);
; 1763 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1764 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1765 :     } else {
; 1766 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1767 :             if (_Is_all_bits_zero(_Val)) {
; 1768 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1769 :                 return;
; 1770 :             }
; 1771 :         }
; 1772 : 
; 1773 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 1774 :         while (_Backout._Last != _ULast) {

  0000b	74 10		 je	 SHORT $LN3@uninitiali
  0000d	56		 push	 esi
  0000e	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
$LL2@uninitiali:

; 1432 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1433 :         ++_Last;

  00015	83 c0 04	 add	 eax, 4

; 1759 :     // copy _Val throughout raw [_First, _Last)
; 1760 :     _Adl_verify_range(_First, _Last);
; 1761 :     auto _UFirst      = _Get_unwrapped(_First);
; 1762 :     const auto _ULast = _Get_unwrapped(_Last);
; 1763 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1764 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1765 :     } else {
; 1766 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1767 :             if (_Is_all_bits_zero(_Val)) {
; 1768 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1769 :                 return;
; 1770 :             }
; 1771 :         }
; 1772 : 
; 1773 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 1774 :         while (_Backout._Last != _ULast) {

  00018	3b c2		 cmp	 eax, edx
  0001a	75 f5		 jne	 SHORT $LL2@uninitiali
  0001c	5e		 pop	 esi
$LN3@uninitiali:

; 1775 :             _Backout._Emplace_back(_Val);
; 1776 :         }
; 1777 : 
; 1778 :         _Backout._Release();
; 1779 :     }
; 1780 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >, COMDAT

; 322  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :         _Head->_Prev->_Next = nullptr;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Head$[ebp]
  00006	57		 push	 edi
  00007	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 324  : 
; 325  :         auto _Pnode = _Head->_Next;

  00010	8b 39		 mov	 edi, DWORD PTR [ecx]

; 326  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00012	85 ff		 test	 edi, edi
  00014	74 3f		 je	 SHORT $LN3@Free_non_h
  00016	53		 push	 ebx
  00017	56		 push	 esi
$LL4@Free_non_h:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  00018	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 327  :             _Pnext = _Pnode->_Next;

  0001b	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  0001d	85 f6		 test	 esi, esi
  0001f	74 21		 je	 SHORT $LN25@Free_non_h

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  00021	83 c8 ff	 or	 eax, -1
  00024	f0 0f c1 46 04	 lock	  xadd	 DWORD PTR [esi+4], eax
  00029	75 17		 jne	 SHORT $LN25@Free_non_h

; 1106 :             _Destroy();

  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	8b ce		 mov	 ecx, esi
  0002f	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  00031	83 c8 ff	 or	 eax, -1
  00034	f0 0f c1 46 08	 lock	  xadd	 DWORD PTR [esi+8], eax
  00039	75 07		 jne	 SHORT $LN25@Free_non_h

; 1113 :             _Delete_this();

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	8b ce		 mov	 ecx, esi
  0003f	ff 50 04	 call	 DWORD PTR [eax+4]
$LN25@Free_non_h:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00042	6a 14		 push	 20			; 00000014H
  00044	57		 push	 edi
  00045	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004a	83 c4 08	 add	 esp, 8
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 326  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0004d	8b fb		 mov	 edi, ebx
  0004f	85 db		 test	 ebx, ebx
  00051	75 c5		 jne	 SHORT $LL4@Free_non_h
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
$LN3@Free_non_h:
  00055	5f		 pop	 edi

; 328  :             _Freenode(_Al, _Pnode);
; 329  :         }
; 330  :     }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >, COMDAT

; 4460 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4461 :     // copy _Val through [_First, _Last)
; 4462 :     _Adl_verify_range(_First, _Last);
; 4463 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 4464 :         _Fill_vbool(_First, _Last, _Val);
; 4465 :     } else {
; 4466 :         auto _UFirst      = _Get_unwrapped(_First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000b	53		 push	 ebx

; 4467 :         const auto _ULast = _Get_unwrapped(_Last);
; 4468 : #ifdef __cpp_lib_is_constant_evaluated
; 4469 :         if (!_STD is_constant_evaluated())
; 4470 : #endif // __cpp_lib_is_constant_evaluated
; 4471 :         {
; 4472 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 4473 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 4474 :                 return;
; 4475 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 4476 :                 if (_Is_all_bits_zero(_Val)) {
; 4477 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 4478 :                     return;
; 4479 :                 }
; 4480 :             }
; 4481 :         }
; 4482 : 
; 4483 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000c	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	2b f2		 sub	 esi, edx
  00014	83 c6 03	 add	 esi, 3
  00017	c1 ee 02	 shr	 esi, 2
  0001a	3b d1		 cmp	 edx, ecx
  0001c	0f 47 f0	 cmova	 esi, eax
  0001f	85 f6		 test	 esi, esi
  00021	74 2b		 je	 SHORT $LN9@fill
  00023	83 fe 04	 cmp	 esi, 4
  00026	72 26		 jb	 SHORT $LN9@fill

; 4484 :             *_UFirst = _Val;

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	57		 push	 edi
  0002b	8d 7a fc	 lea	 edi, DWORD PTR [edx-4]
  0002e	8d 3c b7	 lea	 edi, DWORD PTR [edi+esi*4]
  00031	3b d3		 cmp	 edx, ebx
  00033	77 04		 ja	 SHORT $LN10@fill

; 4461 :     // copy _Val through [_First, _Last)
; 4462 :     _Adl_verify_range(_First, _Last);
; 4463 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 4464 :         _Fill_vbool(_First, _Last, _Val);
; 4465 :     } else {
; 4466 :         auto _UFirst      = _Get_unwrapped(_First);

  00035	3b fb		 cmp	 edi, ebx
  00037	73 14		 jae	 SHORT $LN15@fill
$LN10@fill:
  00039	83 e6 fc	 and	 esi, -4			; fffffffcH
  0003c	8b fa		 mov	 edi, edx
  0003e	c1 e6 02	 shl	 esi, 2
  00041	8b ce		 mov	 ecx, esi
  00043	c1 e9 02	 shr	 ecx, 2
  00046	03 d6		 add	 edx, esi
  00048	f3 ab		 rep stosd
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
$LN15@fill:
  0004d	5f		 pop	 edi
$LN9@fill:

; 4467 :         const auto _ULast = _Get_unwrapped(_Last);
; 4468 : #ifdef __cpp_lib_is_constant_evaluated
; 4469 :         if (!_STD is_constant_evaluated())
; 4470 : #endif // __cpp_lib_is_constant_evaluated
; 4471 :         {
; 4472 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 4473 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 4474 :                 return;
; 4475 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 4476 :                 if (_Is_all_bits_zero(_Val)) {
; 4477 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 4478 :                     return;
; 4479 :                 }
; 4480 :             }
; 4481 :         }
; 4482 : 
; 4483 :         for (; _UFirst != _ULast; ++_UFirst) {

  0004e	3b d1		 cmp	 edx, ecx
  00050	74 0b		 je	 SHORT $LN3@fill
$LL8@fill:

; 4484 :             *_UFirst = _Val;

  00052	8b 03		 mov	 eax, DWORD PTR [ebx]
  00054	89 02		 mov	 DWORD PTR [edx], eax
  00056	83 c2 04	 add	 edx, 4
  00059	3b d1		 cmp	 edx, ecx
  0005b	75 f5		 jne	 SHORT $LL8@fill
$LN3@fill:
  0005d	5e		 pop	 esi

; 4485 :         }
; 4486 :     }
; 4487 : }

  0005e	5b		 pop	 ebx
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z
_TEXT	SEGMENT
tv896 = -28						; size = 8
tv889 = -28						; size = 8
$T2 = -28						; size = 8
__Target$3 = -28					; size = 8
__Newnode$4 = -20					; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Hashval$1$ = 12					; size = 4
_<_Vals_0>$ = 12					; size = 4
_<_Vals_1>$ = 16					; size = 4
??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::emplace<unsigned char const &,std::shared_ptr<CRenderTarget> >, COMDAT
; _this$ = ecx

; 562  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _<_Vals_0>$[ebp]
  0002d	53		 push	 ebx
  0002e	e8 00 00 00 00	 call	 ??$_Hash_representation@E@std@@YAIABE@Z ; std::_Hash_representation<unsigned char>
  00033	83 c4 04	 add	 esp, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 137  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

  00036	89 45 0c	 mov	 DWORD PTR __Hashval$1$[ebp], eax

; 563  :         // try to insert value_type(_Vals...)
; 564  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 565  :         if constexpr (_Multi) {
; 566  :             _Check_max_size();
; 567  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 568  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 569  :             const auto _Hashval = _Traitsobj(_Keyval);
; 570  :             if (_Check_rehash_required_1()) {
; 571  :                 _Rehash_for_1();
; 572  :             }
; 573  : 
; 574  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 575  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 576  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 577  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 578  :             const auto _Hashval = _Traitsobj(_Keyval);
; 579  :             auto _Target        = _Find_last(_Keyval, _Hashval);

  00039	8b cf		 mov	 ecx, edi
  0003b	50		 push	 eax
  0003c	53		 push	 ebx
  0003d	8d 45 e4	 lea	 eax, DWORD PTR __Target$3[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Find_last<unsigned char>

; 580  :             if (_Target._Duplicate) {

  00046	8b 4d e8	 mov	 ecx, DWORD PTR __Target$3[ebp+4]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 1d		 je	 SHORT $LN2@emplace
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00050	89 08		 mov	 DWORD PTR [eax], ecx
  00052	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 612  :     }

  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 0c 00	 ret	 12			; 0000000cH
$LN2@emplace:

; 1579 :         if (_Oldsize == _List.max_size()) {

  0006a	81 7f 08 cc cc
	cc 0c		 cmp	 DWORD PTR [edi+8], 214748364 ; 0cccccccH
  00071	0f 84 72 01 00
	00		 je	 $LN148@emplace

; 581  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 582  :             }
; 583  : 
; 584  :             _Check_max_size();
; 585  :             // invalidates _Keyval:
; 586  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

  00077	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0007a	89 45 ec	 mov	 DWORD PTR __Newnode$4[ebp], eax

; 79   :         return ::operator new(_Bytes);

  0007d	6a 14		 push	 20			; 00000014H
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 582  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0007f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00086	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Newnode$4[ebp+4], 0

; 79   :         return ::operator new(_Bytes);

  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00092	8a 0b		 mov	 cl, BYTE PTR [ebx]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

  00094	8b f0		 mov	 esi, eax

; 79   :         return ::operator new(_Bytes);

  00096	83 c4 04	 add	 esp, 4

; 966  :         _Ptr = _Al.allocate(1);

  00099	89 75 f0	 mov	 DWORD PTR __Newnode$4[ebp+4], esi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0009c	88 4e 08	 mov	 BYTE PTR [esi+8], cl
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1273 :         _Ptr = _Right._Ptr;

  0009f	8b 4d 10	 mov	 ecx, DWORD PTR _<_Vals_1>$[ebp]

; 1398 :     element_type* _Ptr{nullptr};

  000a2	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1399 :     _Ref_count_base* _Rep{nullptr};

  000a9	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1273 :         _Ptr = _Right._Ptr;

  000b0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b2	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 1274 :         _Rep = _Right._Rep;

  000b5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000b8	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1275 : 
; 1276 :         _Right._Ptr = nullptr;

  000bb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1277 :         _Right._Rep = nullptr;

  000c1	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1586 :         const auto _Newsize      = _Oldsize + 1;

  000c8	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 1587 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

  000cb	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  000ce	f3 0f 10 1f	 movss	 xmm3, DWORD PTR [edi]

; 581  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 582  :             }
; 583  : 
; 584  :             _Check_max_size();
; 585  :             // invalidates _Keyval:
; 586  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

  000d2	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1586 :         const auto _Newsize      = _Oldsize + 1;

  000d9	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000dc	66 0f 6e c0	 movd	 xmm0, eax

; 1587 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

  000e0	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000e4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e7	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000f0	8b c3		 mov	 eax, ebx
  000f2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f5	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  000f9	66 0f 6e c3	 movd	 xmm0, ebx
  000fd	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00101	0f 28 ca	 movaps	 xmm1, xmm2
  00104	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0010d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00111	f3 0f 5e c8	 divss	 xmm1, xmm0
  00115	0f 2f cb	 comiss	 xmm1, xmm3

; 587  :             if (_Check_rehash_required_1()) {

  00118	76 6e		 jbe	 SHORT $LN143@emplace

; 1616 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

  0011a	f3 0f 5e d3	 divss	 xmm2, xmm3
; File D:\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h

; 642  :             return (float)ceil(_X);

  0011e	83 ec 08	 sub	 esp, 8
  00121	0f 5a c2	 cvtps2pd xmm0, xmm2
  00124	f2 0f 11 45 e4	 movsd	 QWORD PTR tv896[ebp], xmm0
  00129	dd 45 e4	 fld	 QWORD PTR tv896[ebp]
  0012c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0012f	e8 00 00 00 00	 call	 _ceil
  00134	dd 5d e4	 fstp	 QWORD PTR tv889[ebp]
  00137	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR tv889[ebp]
  0013c	83 c4 08	 add	 esp, 8
  0013f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1616 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

  00143	e8 00 00 00 00	 call	 __ftoui3
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

  00148	b9 08 00 00 00	 mov	 ecx, 8
  0014d	3b c1		 cmp	 eax, ecx
  0014f	0f 47 c8	 cmova	 ecx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1622 :         if (_Old_buckets >= _Req_buckets) {

  00152	3b d9		 cmp	 ebx, ecx
  00154	73 11		 jae	 SHORT $LN64@emplace

; 1623 :             // we already have enough buckets so there's no need to change the count
; 1624 :             return _Old_buckets;
; 1625 :         }
; 1626 : 
; 1627 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

  00156	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  0015c	73 07		 jae	 SHORT $LN66@emplace
  0015e	c1 e3 03	 shl	 ebx, 3
  00161	3b d9		 cmp	 ebx, ecx
  00163	73 02		 jae	 SHORT $LN64@emplace
$LN66@emplace:

; 1628 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1629 :             return _Old_buckets * 8;
; 1630 :         }
; 1631 : 
; 1632 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1633 :         return _Req_buckets;

  00165	8b d9		 mov	 ebx, ecx
$LN64@emplace:

; 1593 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

  00167	53		 push	 ebx
  00168	8b cf		 mov	 ecx, edi
  0016a	e8 00 00 00 00	 call	 ?_Forced_rehash@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Forced_rehash

; 588  :                 _Rehash_for_1();
; 589  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

  0016f	ff 75 0c	 push	 DWORD PTR __Hashval$1$[ebp]
  00172	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00175	8b cf		 mov	 ecx, edi
  00177	50		 push	 eax
  00178	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Find_last<unsigned char>
  00181	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00184	8b 10		 mov	 edx, DWORD PTR [eax]
  00186	eb 03		 jmp	 SHORT $LN3@emplace
$LN143@emplace:

; 587  :             if (_Check_rehash_required_1()) {

  00188	8b 55 e4	 mov	 edx, DWORD PTR __Target$3[ebp]
$LN3@emplace:

; 1547 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

  0018b	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]

; 1548 :         ++_List._Mypair._Myval2._Mysize;

  0018e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00191	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1549 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

  00194	89 16		 mov	 DWORD PTR [esi], edx

; 1550 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

  00196	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 1551 :         _Insert_after->_Next  = _Newnode;

  00199	89 33		 mov	 DWORD PTR [ebx], esi

; 1552 :         _Insert_before->_Prev = _Newnode;

  0019b	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 1553 : 
; 1554 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1555 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1556 :         const size_type _Bucket         = _Hashval & _Mask;

  0019e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  001a1	23 45 0c	 and	 eax, DWORD PTR __Hashval$1$[ebp]
  001a4	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]

; 1557 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];
; 1558 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1559 :         if (_Bucket_lo._Ptr == _Head) {

  001a7	8b 75 ec	 mov	 esi, DWORD PTR __Newnode$4[ebp]
  001aa	8b 3c c1	 mov	 edi, DWORD PTR [ecx+eax*8]
  001ad	3b 3e		 cmp	 edi, DWORD PTR [esi]
  001af	8b 75 f0	 mov	 esi, DWORD PTR __Newnode$4[ebp+4]
  001b2	75 05		 jne	 SHORT $LN81@emplace

; 1560 :             // bucket is empty, set both
; 1561 :             _Bucket_lo._Ptr = _Newnode;

  001b4	89 34 c1	 mov	 DWORD PTR [ecx+eax*8], esi

; 1562 :             _Bucket_hi._Ptr = _Newnode;

  001b7	eb 0f		 jmp	 SHORT $LN146@emplace
$LN81@emplace:

; 1563 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

  001b9	3b fa		 cmp	 edi, edx
  001bb	75 05		 jne	 SHORT $LN83@emplace

; 1564 :             // new node is the lowest element in the bucket
; 1565 :             _Bucket_lo._Ptr = _Newnode;

  001bd	89 34 c1	 mov	 DWORD PTR [ecx+eax*8], esi
  001c0	eb 0a		 jmp	 SHORT $LN85@emplace
$LN83@emplace:

; 1566 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

  001c2	39 5c c1 04	 cmp	 DWORD PTR [ecx+eax*8+4], ebx
  001c6	75 04		 jne	 SHORT $LN85@emplace
$LN146@emplace:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001c8	89 74 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], esi
$LN85@emplace:
  001cc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001cf	89 30		 mov	 DWORD PTR [eax], esi
  001d1	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 612  :     }

  001d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001df	59		 pop	 ecx
  001e0	5f		 pop	 edi
  001e1	5e		 pop	 esi
  001e2	5b		 pop	 ebx
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c2 0c 00	 ret	 12			; 0000000cH
$LN148@emplace:

; 1580 :             _Xlength_error("unordered_map/set too long");

  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
  001ee	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN145@emplace:
  001f3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z$1:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Newnode$4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
__unwindfunclet$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z$0:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR __Newnode$4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::emplace<unsigned char const &,std::shared_ptr<CRenderTarget> >
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ??1?$shared_ptr@VCRenderTarget@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$shared_ptr@VCRenderTarget@@@std@@QAE@XZ PROC	; std::shared_ptr<CRenderTarget>::~shared_ptr<CRenderTarget>, COMDAT
; _this$ = ecx

; 1613 :     ~shared_ptr() noexcept { // release resource

  00000	56		 push	 esi

; 1330 :         if (_Rep) {

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	74 25		 je	 SHORT $LN10@shared_ptr

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  00008	57		 push	 edi
  00009	83 cf ff	 or	 edi, -1
  0000c	8b c7		 mov	 eax, edi
  0000e	f0 0f c1 46 04	 lock	  xadd	 DWORD PTR [esi+4], eax
  00013	75 17		 jne	 SHORT $LN12@shared_ptr

; 1106 :             _Destroy();

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	8b ce		 mov	 ecx, esi
  00019	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  0001b	f0 0f c1 7e 08	 lock	  xadd	 DWORD PTR [esi+8], edi
  00020	4f		 dec	 edi
  00021	75 09		 jne	 SHORT $LN12@shared_ptr

; 1113 :             _Delete_this();

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	8b ce		 mov	 ecx, esi
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN12@shared_ptr:
  0002c	5f		 pop	 edi
$LN10@shared_ptr:
  0002d	5e		 pop	 esi

; 1614 :         this->_Decref();
; 1615 :     }

  0002e	c3		 ret	 0
??1?$shared_ptr@VCRenderTarget@@@std@@QAE@XZ ENDP	; std::shared_ptr<CRenderTarget>::~shared_ptr<CRenderTarget>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCRenderTargetManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRenderTargetManager@@UAEPAXI@Z PROC		; CRenderTargetManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CRenderTargetManager@@UAE@XZ ; CRenderTargetManager::~CRenderTargetManager
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCRenderTargetManager@@UAEPAXI@Z ENDP		; CRenderTargetManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::~_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >, COMDAT
; _this$ = ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 268  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00006	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00009	2b d0		 sub	 edx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	83 e2 fc	 and	 edx, -4			; fffffffcH

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN23@Hash

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00019	83 c2 23	 add	 edx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c1		 sub	 eax, ecx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 37		 ja	 SHORT $LN20@Hash

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c1		 mov	 eax, ecx
$LN23@Hash:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	52		 push	 edx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 302  :         _Mypair._Myval2._Myfirst = nullptr;

  0002f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 303  :         _Mypair._Myval2._Mylast  = nullptr;

  00036	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 304  :         _Mypair._Myval2._Myend   = nullptr;

  0003d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00044	83 c6 04	 add	 esi, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1431 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00047	ff 36		 push	 DWORD PTR [esi]
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0004f	6a 14		 push	 20			; 00000014H
  00051	ff 36		 push	 DWORD PTR [esi]
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00058	83 c4 18	 add	 esp, 24			; 00000018H
  0005b	5e		 pop	 esi
  0005c	c3		 ret	 0
$LN20@Hash:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN55@Hash:
  00062	cc		 int	 3
??1?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::~_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >, COMDAT
; _this$ = ecx

; 307  :     ~_Hash_vec() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 268  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

  00003	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	2b d0		 sub	 edx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000a	83 e2 fc	 and	 edx, -4			; fffffffcH

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000d	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00013	72 12		 jb	 SHORT $LN21@Hash_vec

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00015	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00018	83 c2 23	 add	 edx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001b	2b c1		 sub	 eax, ecx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00020	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00023	77 22		 ja	 SHORT $LN18@Hash_vec

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00025	8b c1		 mov	 eax, ecx
$LN21@Hash_vec:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00027	52		 push	 edx
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002e	83 c4 08	 add	 esp, 8
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 302  :         _Mypair._Myval2._Myfirst = nullptr;

  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 303  :         _Mypair._Myval2._Mylast  = nullptr;

  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 304  :         _Mypair._Myval2._Myend   = nullptr;

  0003e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00045	5e		 pop	 esi

; 313  :     }

  00046	c3		 ret	 0
$LN18@Hash_vec:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@Hash_vec:
  0004c	cc		 int	 3
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Cells$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::_Assign_grow, COMDAT
; _this$ = ecx

; 276  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c1		 mov	 eax, ecx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 277  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 278  :         const auto _Oldsize = size();
; 279  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 280  :         auto& _Alvec = _Mypair._Get_first();
; 281  :         if (_Oldsize < _Cells) {

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Cells$[ebp]

; 268  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	2b f2		 sub	 esi, edx
  00014	c1 fe 02	 sar	 esi, 2

; 276  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

  00017	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax

; 277  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 278  :         const auto _Oldsize = size();
; 279  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 280  :         auto& _Alvec = _Mypair._Get_first();
; 281  :         if (_Oldsize < _Cells) {

  0001a	3b f7		 cmp	 esi, edi
  0001c	0f 83 90 00 00
	00		 jae	 $LN2@Assign_gro
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00022	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00028	0f 87 9a 00 00
	00		 ja	 $LN40@Assign_gro

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0002e	c1 e7 02	 shl	 edi, 2
  00031	53		 push	 ebx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00032	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00038	72 10		 jb	 SHORT $LN15@Assign_gro

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00040	8b d8		 mov	 ebx, eax
  00042	83 c4 04	 add	 esp, 4
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00048	eb 16		 jmp	 SHORT $LN14@Assign_gro
$LN15@Assign_gro:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  0004a	85 ff		 test	 edi, edi
  0004c	74 10		 je	 SHORT $LN16@Assign_gro

; 79   :         return ::operator new(_Bytes);

  0004e	57		 push	 edi
  0004f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

  00054	8b d8		 mov	 ebx, eax

; 79   :         return ::operator new(_Bytes);

  00056	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0005c	eb 02		 jmp	 SHORT $LN14@Assign_gro
$LN16@Assign_gro:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  0005e	33 db		 xor	 ebx, ebx
$LN14@Assign_gro:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 284  :             if (_Oldsize != 0) {

  00060	85 f6		 test	 esi, esi
  00062	74 29		 je	 SHORT $LN25@Assign_gro
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	c1 e6 02	 shl	 esi, 2

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00069	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0006f	72 12		 jb	 SHORT $LN35@Assign_gro

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00071	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00074	83 c6 23	 add	 esi, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00077	2b c1		 sub	 eax, ecx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00079	83 c0 fc	 add	 eax, -4			; fffffffcH
  0007c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0007f	77 4c		 ja	 SHORT $LN32@Assign_gro

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00081	8b c1		 mov	 eax, ecx
$LN35@Assign_gro:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00083	56		 push	 esi
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008a	83 c4 08	 add	 esp, 8
$LN25@Assign_gro:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 289  :             _Mypair._Myval2._Myfirst = _Newvec;

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]

; 290  :             const auto _Newend       = _Newvec + _Cells;

  00090	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  00093	89 19		 mov	 DWORD PTR [ecx], ebx

; 291  :             _Mypair._Myval2._Mylast  = _Newend;

  00095	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 292  :             _Mypair._Myval2._Myend   = _Newend;

  00098	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 293  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

  0009b	8d 4d 0c	 lea	 ecx, DWORD PTR __Val$[ebp]
  0009e	51		 push	 ecx
  0009f	50		 push	 eax
  000a0	53		 push	 ebx
  000a1	e8 00 00 00 00	 call	 ??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	5b		 pop	 ebx
  000aa	5f		 pop	 edi

; 297  :     }

  000ab	5e		 pop	 esi
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
$LN2@Assign_gro:

; 294  :         } else {
; 295  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

  000b2	8d 45 0c	 lea	 eax, DWORD PTR __Val$[ebp]
  000b5	50		 push	 eax
  000b6	51		 push	 ecx
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	5f		 pop	 edi

; 297  :     }

  000c1	5e		 pop	 esi
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
$LN40@Assign_gro:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000c8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN32@Assign_gro:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN38@Assign_gro:
  000d2	cc		 int	 3
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
__Bucket_lo$1$ = -8					; size = 4
__End$1$ = -4						; size = 4
__First_prev$1$ = 8					; size = 4
tv785 = 8						; size = 4
tv784 = 8						; size = 4
__Buckets$ = 8						; size = 4
tv778 = 11						; size = 1
?_Forced_rehash@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Forced_rehash, COMDAT
; _this$ = ecx

; 1640 :     void _Forced_rehash(size_type _Buckets) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1649 :         if (_Buckets > _Max_storage_buckets) {

  00006	8b 55 08	 mov	 edx, DWORD PTR __Buckets$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h

; 43   :     _BitScanReverse(&_Result, _Value);

  00009	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1640 :     void _Forced_rehash(size_type _Buckets) {

  0000e	53		 push	 ebx
  0000f	8b d9		 mov	 ebx, ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h

; 43   :     _BitScanReverse(&_Result, _Value);

  00011	0f bd c8	 bsr	 ecx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1640 :     void _Forced_rehash(size_type _Buckets) {

  00014	56		 push	 esi

; 1641 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1642 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1643 :         // load_factor() <= max_load_factor().
; 1644 : 
; 1645 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1646 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1647 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));
; 1648 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

  00015	be 01 00 00 00	 mov	 esi, 1
  0001a	89 5d f4	 mov	 DWORD PTR _this$1$[ebp], ebx
  0001d	8b c6		 mov	 eax, esi
  0001f	d3 e0		 shl	 eax, cl
  00021	57		 push	 edi

; 1649 :         if (_Buckets > _Max_storage_buckets) {

  00022	3b d0		 cmp	 edx, eax
  00024	0f 87 18 01 00
	00		 ja	 $LN108@Forced_reh
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h

; 52   :     return 1 + _Floor_of_log_2(_Value - 1);

  0002a	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

  0002d	0b c6		 or	 eax, esi

; 43   :     _BitScanReverse(&_Result, _Value);

  0002f	0f bd c8	 bsr	 ecx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00032	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1660 :         _Vec._Assign_grow(_Buckets << 1, _End);

  00035	50		 push	 eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00036	89 45 fc	 mov	 DWORD PTR __End$1$[ebp], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xbit_ops.h

; 52   :     return 1 + _Floor_of_log_2(_Value - 1);

  00039	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1657 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

  0003c	d3 e6		 shl	 esi, cl

; 1660 :         _Vec._Assign_grow(_Buckets << 1, _End);

  0003e	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00041	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::_Assign_grow

; 1661 :         _Mask   = _Buckets - 1;

  0004a	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]

; 1662 :         _Maxidx = _Buckets;

  0004d	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00050	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1661 :         _Mask   = _Buckets - 1;

  00053	89 43 18	 mov	 DWORD PTR [ebx+24], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00056	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1669 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

  00058	8b fe		 mov	 edi, esi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  0005a	3b 75 fc	 cmp	 esi, DWORD PTR __End$1$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1669 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

  0005d	0f 84 b2 00 00
	00		 je	 $LN3@Forced_reh
$LL4@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00063	8b 3f		 mov	 edi, DWORD PTR [edi]

; 43   :         return _Ptr->_Myval;

  00065	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Hash_representation@E@std@@YAIABE@Z ; std::_Hash_representation<unsigned char>
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 830  :         return _Traitsobj(_Keyval) & _Mask;

  0006e	23 43 18	 and	 eax, DWORD PTR [ebx+24]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  00071	83 c4 04	 add	 esp, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1677 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

  00074	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  00077	8b 1c c1	 mov	 ebx, DWORD PTR [ecx+eax*8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1677 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

  0007a	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __End$1$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1677 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

  00080	89 45 f8	 mov	 DWORD PTR __Bucket_lo$1$[ebp], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  00083	3b d9		 cmp	 ebx, ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1680 :             if (_Bucket_lo == _End) {

  00085	75 0a		 jne	 SHORT $LN9@Forced_reh

; 1681 :                 // The bucket was empty, set it to the inserted element.
; 1682 :                 _Bucket_lo = _Inserted;

  00087	89 30		 mov	 DWORD PTR [eax], esi

; 1683 :                 _Bucket_hi = _Inserted;

  00089	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1684 :                 continue;

  0008c	e9 77 00 00 00	 jmp	 $LN2@Forced_reh
$LN9@Forced_reh:

; 1685 :             }
; 1686 : 
; 1687 :             // Search the bucket for the insertion location and move element if necessary.
; 1688 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

  00091	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef

; 84   :         return _Left == _Right;

  00094	8a 56 08	 mov	 dl, BYTE PTR [esi+8]
  00097	3a 50 08	 cmp	 dl, BYTE PTR [eax+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1689 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

  0009a	75 2f		 jne	 SHORT $LN10@Forced_reh
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
  0009e	89 45 08	 mov	 DWORD PTR tv784[ebp], eax
  000a1	3b c6		 cmp	 eax, esi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1693 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

  000a3	74 1e		 je	 SHORT $LN105@Forced_reh
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 473  :         const auto _First_prev  = _First->_Prev;

  000a5	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 481  :         _Before->_Prev = _Last_prev;

  000a8	8b 4d 08	 mov	 ecx, DWORD PTR tv784[ebp]
  000ab	89 3b		 mov	 DWORD PTR [ebx], edi
  000ad	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000b0	89 02		 mov	 DWORD PTR [edx], eax
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	89 30		 mov	 DWORD PTR [eax], esi
  000b7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR __End$1$[ebp]

; 482  :         _Last->_Prev   = _First_prev;

  000bd	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 483  :         _First->_Prev  = _Before_prev;

  000c0	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN105@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1697 :                 _Bucket_hi = _Inserted;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR __Bucket_lo$1$[ebp]
  000c6	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1698 :                 continue;

  000c9	eb 3d		 jmp	 SHORT $LN2@Forced_reh
$LN10@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  000cb	8b d0		 mov	 edx, eax
  000cd	3b d8		 cmp	 ebx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1704 :                 if (_Bucket_lo == _Insert_before) {

  000cf	74 14		 je	 SHORT $LN98@Forced_reh
$LL5@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 62   :         _Ptr = _Ptr->_Prev;

  000d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d4	8b d0		 mov	 edx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xstddef

; 84   :         return _Left == _Right;

  000d6	8a 4e 08	 mov	 cl, BYTE PTR [esi+8]
  000d9	3a 48 08	 cmp	 cl, BYTE PTR [eax+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1714 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __End$1$[ebp]
  000df	74 3d		 je	 SHORT $LN99@Forced_reh
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  000e1	3b d8		 cmp	 ebx, eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1704 :                 if (_Bucket_lo == _Insert_before) {

  000e3	75 ec		 jne	 SHORT $LL5@Forced_reh
$LN98@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 473  :         const auto _First_prev  = _First->_Prev;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	89 45 08	 mov	 DWORD PTR __First_prev$1$[ebp], eax

; 474  :         _First_prev->_Next      = _Last;

  000eb	89 38		 mov	 DWORD PTR [eax], edi

; 475  :         const auto _Last_prev   = _Last->_Prev;

  000ed	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]

; 476  :         _Last_prev->_Next       = _Before;

  000f0	89 13		 mov	 DWORD PTR [ebx], edx

; 477  :         const auto _Before_prev = _Before->_Prev;

  000f2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 478  :         _Before_prev->_Next     = _First;

  000f5	89 30		 mov	 DWORD PTR [eax], esi

; 481  :         _Before->_Prev = _Last_prev;

  000f7	89 5a 04	 mov	 DWORD PTR [edx+4], ebx

; 482  :         _Last->_Prev   = _First_prev;

  000fa	8b 55 08	 mov	 edx, DWORD PTR __First_prev$1$[ebp]
  000fd	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 483  :         _First->_Prev  = _Before_prev;

  00100	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1710 :                     _Bucket_lo = _Inserted;

  00103	8b 45 f8	 mov	 eax, DWORD PTR __Bucket_lo$1$[ebp]
  00106	89 30		 mov	 DWORD PTR [eax], esi
$LN2@Forced_reh:

; 1669 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

  00108	8b 5d f4	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0010b	8b f7		 mov	 esi, edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 73   :         return _Ptr == _Right._Ptr;

  0010d	3b f9		 cmp	 edi, ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1669 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

  0010f	0f 85 4e ff ff
	ff		 jne	 $LL4@Forced_reh
$LN3@Forced_reh:
  00115	5f		 pop	 edi

; 1720 :                     break;
; 1721 :                 }
; 1722 :             }
; 1723 :         }
; 1724 : 
; 1725 :         _Guard._Target = nullptr;
; 1726 : 
; 1727 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1728 :         _Stl_internal_check_container_invariants();
; 1729 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1730 :     }

  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 04 00	 ret	 4
$LN99@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 473  :         const auto _First_prev  = _First->_Prev;

  0011e	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1719 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

  00121	8b 00		 mov	 eax, DWORD PTR [eax]
  00123	89 45 08	 mov	 DWORD PTR tv785[ebp], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 481  :         _Before->_Prev = _Last_prev;

  00126	8b c8		 mov	 ecx, eax
  00128	89 3b		 mov	 DWORD PTR [ebx], edi
  0012a	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0012d	89 02		 mov	 DWORD PTR [edx], eax
  0012f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00132	89 30		 mov	 DWORD PTR [eax], esi
  00134	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 483  :         _First->_Prev  = _Before_prev;

  00137	8b 4d fc	 mov	 ecx, DWORD PTR __End$1$[ebp]
  0013a	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0013d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00140	eb c6		 jmp	 SHORT $LN2@Forced_reh
$LN108@Forced_reh:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1650 :             _Xlength_error("invalid hash bucket count");

  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
  00147	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN106@Forced_reh:
  0014c	cc		 int	 3
?_Forced_rehash@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?clear@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::clear, COMDAT
; _this$ = ecx

; 1096 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1097 :         // TRANSITION, ABI:
; 1098 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1099 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1100 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1101 :         //   (2) The hash function operator() may throw exceptions, and
; 1102 :         //   (3) clear() is a noexcept function.
; 1103 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1104 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

  00007	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1105 :         if (_Oldsize == 0) {

  0000a	85 c9		 test	 ecx, ecx
  0000c	74 50		 je	 SHORT $LN1@clear

; 1106 :             return;
; 1107 :         }
; 1108 : 
; 1109 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1110 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1111 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1112 :             // as many buckets as elements, remove element-by-element.
; 1113 :             if (bucket_count() / 8 > _Oldsize) {

  0000e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00011	c1 e8 03	 shr	 eax, 3
  00014	57		 push	 edi
  00015	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00018	3b c1		 cmp	 eax, ecx
  0001a	76 12		 jbe	 SHORT $LN3@clear

; 1114 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

  0001c	8b 07		 mov	 eax, DWORD PTR [edi]

; 1115 :                 _Unchecked_erase(_Head->_Next, _Head);

  0001e	8b ce		 mov	 ecx, esi
  00020	50		 push	 eax
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@2@PAU32@QAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Unchecked_erase
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 1123 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN3@clear:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1420 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0002e	ff 37		 push	 DWORD PTR [edi]
  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >

; 1421 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00036	8b 07		 mov	 eax, DWORD PTR [edi]
  00038	89 00		 mov	 DWORD PTR [eax], eax

; 1422 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  0003a	8b 07		 mov	 eax, DWORD PTR [edi]
  0003c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1423 :         _My_data._Mysize        = 0;

  0003f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1122 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

  0004b	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0004e	50		 push	 eax
  0004f	ff 76 10	 push	 DWORD PTR [esi+16]
  00052	ff 76 0c	 push	 DWORD PTR [esi+12]
  00055	e8 00 00 00 00	 call	 ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > >
  0005a	83 c4 14	 add	 esp, 20			; 00000014H
  0005d	5f		 pop	 edi
$LN1@clear:
  0005e	5e		 pop	 esi

; 1123 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?clear@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@2@PAU32@QAU32@@Z
_TEXT	SEGMENT
_this$1$ = -40						; size = 4
tv674 = -36						; size = 4
tv670 = -36						; size = 4
tv675 = -32						; size = 4
tv671 = -32						; size = 4
__Oldnext$1$ = -28					; size = 4
_this$1$ = -24						; size = 4
__End$1$ = -20						; size = 4
__Bucket_bounds$1$ = -16				; size = 4
tv673 = -12						; size = 4
__Bucket_lo$1$ = -8					; size = 4
__Eraser$$sroa$173$1$ = -4				; size = 4
__Bucket_lo$1$ = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@2@PAU32@QAU32@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 989  :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 990  :         if (_First == _Last) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 5d d8	 mov	 DWORD PTR _this$1$[ebp], ebx
  00013	3b c7		 cmp	 eax, edi
  00015	75 0a		 jne	 SHORT $LN10@Unchecked_

; 991  :             return _Last;

  00017	8b c7		 mov	 eax, edi
  00019	5f		 pop	 edi

; 1059 :     }

  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
$LN10@Unchecked_:

; 992  :         }
; 993  : 
; 994  :         const auto _End           = _List._Mypair._Myval2._Myhead;

  00021	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00024	89 4d ec	 mov	 DWORD PTR __End$1$[ebp], ecx

; 995  :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

  00027	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0002a	56		 push	 esi
  0002b	89 4d f0	 mov	 DWORD PTR __Bucket_bounds$1$[ebp], ecx

; 969  :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

  0002e	8b f0		 mov	 esi, eax
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 996  :         _Range_eraser _Eraser{_List, _First};
; 997  :         {
; 998  :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 999  :             const auto _Predecessor = _First->_Prev;
; 1000 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

  00033	83 c0 08	 add	 eax, 8
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  00036	50		 push	 eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 969  :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

  00037	89 4d fc	 mov	 DWORD PTR __Eraser$$sroa$173$1$[ebp], ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  0003a	e8 00 00 00 00	 call	 ??$_Hash_representation@E@std@@YAIABE@Z ; std::_Hash_representation<unsigned char>
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1002 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR __Bucket_bounds$1$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  00042	83 c4 04	 add	 esp, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 830  :         return _Traitsobj(_Keyval) & _Mask;

  00045	23 43 18	 and	 eax, DWORD PTR [ebx+24]

; 1002 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  00048	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1003 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1004 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	89 45 f8	 mov	 DWORD PTR __Bucket_lo$1$[ebp], eax

; 1005 :             const _Nodeptr _Old_hi = _Bucket_hi;

  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	89 4d f4	 mov	 DWORD PTR tv673[ebp], ecx
  00056	89 45 e0	 mov	 DWORD PTR tv671[ebp], eax
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Unchecked_:

; 972  :             const auto _Oldnext = _Next;

  00060	8b ce		 mov	 ecx, esi

; 1006 :             for (;;) { // remove elements until we hit the end of the bucket
; 1007 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

  00062	89 75 dc	 mov	 DWORD PTR tv674[ebp], esi

; 973  :             _Next               = _Oldnext->_Next;

  00065	8b 36		 mov	 esi, DWORD PTR [esi]
  00067	89 4d e4	 mov	 DWORD PTR __Oldnext$1$[ebp], ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  0006a	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0006d	89 4d e8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00070	85 c9		 test	 ecx, ecx
  00072	74 20		 je	 SHORT $LN50@Unchecked_

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  00074	83 c8 ff	 or	 eax, -1
  00077	f0 0f c1 41 04	 lock	  xadd	 DWORD PTR [ecx+4], eax
  0007c	75 16		 jne	 SHORT $LN50@Unchecked_

; 1106 :             _Destroy();

  0007e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00080	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  00082	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00085	83 c8 ff	 or	 eax, -1
  00088	f0 0f c1 41 08	 lock	  xadd	 DWORD PTR [ecx+8], eax
  0008d	75 05		 jne	 SHORT $LN50@Unchecked_

; 1113 :             _Delete_this();

  0008f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00091	ff 50 04	 call	 DWORD PTR [eax+4]
$LN50@Unchecked_:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00094	6a 14		 push	 20			; 00000014H
  00096	ff 75 e4	 push	 DWORD PTR __Oldnext$1$[ebp]
  00099	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 975  :             --_List._Mypair._Myval2._Mysize;

  0009e	ff 4b 08	 dec	 DWORD PTR [ebx+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  000a1	83 c4 08	 add	 esp, 8
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1009 :                 if (_At_bucket_back) {

  000a4	8b 45 e0	 mov	 eax, DWORD PTR tv671[ebp]
  000a7	39 45 dc	 cmp	 DWORD PTR tv674[ebp], eax
  000aa	74 24		 je	 SHORT $LN139@Unchecked_

; 1010 :                     break;
; 1011 :                 }
; 1012 : 
; 1013 :                 if (_Eraser._Next == _Last) {

  000ac	3b f7		 cmp	 esi, edi
  000ae	75 b0		 jne	 SHORT $LL2@Unchecked_

; 1014 :                     if (_Update_lo) {

  000b0	8b 45 f4	 mov	 eax, DWORD PTR tv673[ebp]
  000b3	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  000b6	75 05		 jne	 SHORT $LN149@Unchecked_

; 1015 :                         // erased the bucket's prefix
; 1016 :                         _Bucket_lo = _Eraser._Next;

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR __Bucket_lo$1$[ebp]
  000bb	89 31		 mov	 DWORD PTR [ecx], esi
$LN149@Unchecked_:

; 979  :             _Predecessor->_Next = _Next;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR __Eraser$$sroa$173$1$[ebp]
  000c0	89 30		 mov	 DWORD PTR [eax], esi

; 980  :             _Next->_Prev        = _Predecessor;

  000c2	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1056 :         }
; 1057 : 
; 1058 :         return _Last;

  000c5	8b c7		 mov	 eax, edi
  000c7	5e		 pop	 esi
  000c8	5f		 pop	 edi

; 1059 :     }

  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 08 00	 ret	 8
$LN139@Unchecked_:

; 1017 :                     }
; 1018 : 
; 1019 :                     return _Last;
; 1020 :                 }
; 1021 :             }
; 1022 : 
; 1023 :             if (_Update_lo) {

  000d0	8b 45 f4	 mov	 eax, DWORD PTR tv673[ebp]
  000d3	8b 4d f8	 mov	 ecx, DWORD PTR __Bucket_lo$1$[ebp]
  000d6	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  000d9	75 07		 jne	 SHORT $LN14@Unchecked_

; 1024 :                 // emptied the bucket
; 1025 :                 _Bucket_lo = _End;

  000db	8b 45 ec	 mov	 eax, DWORD PTR __End$1$[ebp]
  000de	89 01		 mov	 DWORD PTR [ecx], eax

; 1026 :                 _Bucket_hi = _End;
; 1027 :             } else {

  000e0	eb 03		 jmp	 SHORT $LN136@Unchecked_
$LN14@Unchecked_:

; 1028 :                 _Bucket_hi = _Predecessor;

  000e2	8b 45 fc	 mov	 eax, DWORD PTR __Eraser$$sroa$173$1$[ebp]
$LN136@Unchecked_:

; 1029 :             }
; 1030 :         }
; 1031 : 
; 1032 :         // hereafter we are always erasing buckets' prefixes
; 1033 :         while (_Eraser._Next != _Last) {

  000e5	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000e8	3b f7		 cmp	 esi, edi
  000ea	74 d1		 je	 SHORT $LN149@Unchecked_
  000ec	0f 1f 40 00	 npad	 4
$LL5@Unchecked_:

; 1034 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

  000f0	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ??$_Hash_representation@E@std@@YAIABE@Z ; std::_Hash_representation<unsigned char>
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1036 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  000f9	8b 4d f0	 mov	 ecx, DWORD PTR __Bucket_bounds$1$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  000fc	83 c4 04	 add	 esp, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 830  :         return _Traitsobj(_Keyval) & _Mask;

  000ff	23 43 18	 and	 eax, DWORD PTR [ebx+24]

; 1036 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

  00102	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00105	89 45 08	 mov	 DWORD PTR __Bucket_lo$1$[ebp], eax

; 1037 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1038 :             const _Nodeptr _Old_hi = _Bucket_hi;

  00108	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0010b	89 45 dc	 mov	 DWORD PTR tv670[ebp], eax
  0010e	66 90		 npad	 2
$LL7@Unchecked_:

; 972  :             const auto _Oldnext = _Next;

  00110	8b de		 mov	 ebx, esi

; 1039 :             for (;;) { // remove elements until we hit the end of the bucket
; 1040 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

  00112	89 75 e0	 mov	 DWORD PTR tv675[ebp], esi

; 973  :             _Next               = _Oldnext->_Next;

  00115	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  00117	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0011a	85 ff		 test	 edi, edi
  0011c	74 21		 je	 SHORT $LN106@Unchecked_

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  0011e	83 c8 ff	 or	 eax, -1
  00121	f0 0f c1 47 04	 lock	  xadd	 DWORD PTR [edi+4], eax
  00126	75 17		 jne	 SHORT $LN106@Unchecked_

; 1106 :             _Destroy();

  00128	8b 07		 mov	 eax, DWORD PTR [edi]
  0012a	8b cf		 mov	 ecx, edi
  0012c	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  0012e	83 c8 ff	 or	 eax, -1
  00131	f0 0f c1 47 08	 lock	  xadd	 DWORD PTR [edi+8], eax
  00136	75 07		 jne	 SHORT $LN106@Unchecked_

; 1113 :             _Delete_this();

  00138	8b 07		 mov	 eax, DWORD PTR [edi]
  0013a	8b cf		 mov	 ecx, edi
  0013c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN106@Unchecked_:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0013f	6a 14		 push	 20			; 00000014H
  00141	53		 push	 ebx
  00142	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 975  :             --_List._Mypair._Myval2._Mysize;

  00147	8b 5d d8	 mov	 ebx, DWORD PTR _this$1$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0014a	83 c4 08	 add	 esp, 8
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1042 :                 if (_At_bucket_back) {

  0014d	8b 45 dc	 mov	 eax, DWORD PTR tv670[ebp]

; 975  :             --_List._Mypair._Myval2._Mysize;

  00150	ff 4b 08	 dec	 DWORD PTR [ebx+8]

; 1042 :                 if (_At_bucket_back) {

  00153	39 45 e0	 cmp	 DWORD PTR tv675[ebp], eax
  00156	74 1d		 je	 SHORT $LN141@Unchecked_

; 1043 :                     break;
; 1044 :                 }
; 1045 : 
; 1046 :                 if (_Eraser._Next == _Last) {

  00158	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0015b	3b f0		 cmp	 esi, eax
  0015d	75 b1		 jne	 SHORT $LL7@Unchecked_

; 1047 :                     // erased the bucket's prefix
; 1048 :                     _Bucket_lo = _Eraser._Next;

  0015f	8b 4d 08	 mov	 ecx, DWORD PTR __Bucket_lo$1$[ebp]
  00162	89 31		 mov	 DWORD PTR [ecx], esi

; 979  :             _Predecessor->_Next = _Next;

  00164	8b 4d fc	 mov	 ecx, DWORD PTR __Eraser$$sroa$173$1$[ebp]
  00167	89 31		 mov	 DWORD PTR [ecx], esi

; 980  :             _Next->_Prev        = _Predecessor;

  00169	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0016c	5e		 pop	 esi
  0016d	5f		 pop	 edi

; 1059 :     }

  0016e	5b		 pop	 ebx
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 08 00	 ret	 8
$LN141@Unchecked_:

; 1049 :                     return _Last;
; 1050 :                 }
; 1051 :             }
; 1052 : 
; 1053 :             // emptied the bucket
; 1054 :             _Bucket_lo = _End;

  00175	8b 4d 08	 mov	 ecx, DWORD PTR __Bucket_lo$1$[ebp]
  00178	8b 45 ec	 mov	 eax, DWORD PTR __End$1$[ebp]
  0017b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0017e	89 01		 mov	 DWORD PTR [ecx], eax

; 1055 :             _Bucket_hi = _End;

  00180	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00183	3b f7		 cmp	 esi, edi
  00185	0f 85 65 ff ff
	ff		 jne	 $LL5@Unchecked_

; 979  :             _Predecessor->_Next = _Next;

  0018b	8b 45 fc	 mov	 eax, DWORD PTR __Eraser$$sroa$173$1$[ebp]
  0018e	89 30		 mov	 DWORD PTR [eax], esi

; 980  :             _Next->_Prev        = _Predecessor;

  00190	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1056 :         }
; 1057 : 
; 1058 :         return _Last;

  00193	8b c7		 mov	 eax, edi
  00195	5e		 pop	 esi
  00196	5f		 pop	 edi

; 1059 :     }

  00197	5b		 pop	 ebx
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c2 08 00	 ret	 8
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@2@PAU32@QAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
;	COMDAT ??1?$list@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >::~list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >, COMDAT
; _this$ = ecx

; 1036 :     ~list() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1431 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,void *> > >
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000b	6a 14		 push	 20			; 00000014H
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	83 c4 10	 add	 esp, 16			; 00000010H
  00017	5e		 pop	 esi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1042 :     }

  00018	c3		 ret	 0
??1?$list@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >::~list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?RenderModels@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?RenderModels@CRenderTargetManager@@QAEXXZ PROC		; CRenderTargetManager::RenderModels, COMDAT
; _this$ = ecx

; 41   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00002	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 37		 mov	 esi, DWORD PTR [edi]

; 73   :         return _Ptr == _Right._Ptr;

  00007	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 42   : 	for (const auto& elem : m_renderTargets)

  00009	74 13		 je	 SHORT $LN3@RenderMode
  0000b	0f 1f 44 00 00	 npad	 5
$LL25@RenderMode:

; 43   : 		elem.second->RenderModel();

  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 ?RenderModel@CRenderTarget@@QBEXXZ ; CRenderTarget::RenderModel
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 73   :         return _Ptr == _Right._Ptr;

  0001a	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 42   : 	for (const auto& elem : m_renderTargets)

  0001c	75 f2		 jne	 SHORT $LL25@RenderMode
$LN3@RenderMode:
  0001e	5f		 pop	 edi

; 44   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?RenderModels@CRenderTargetManager@@QAEXXZ ENDP		; CRenderTargetManager::RenderModels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?RenderBackgrounds@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?RenderBackgrounds@CRenderTargetManager@@QAEXXZ PROC	; CRenderTargetManager::RenderBackgrounds, COMDAT
; _this$ = ecx

; 35   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00002	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 37		 mov	 esi, DWORD PTR [edi]

; 73   :         return _Ptr == _Right._Ptr;

  00007	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 36   : 	for (const auto& elem : m_renderTargets)

  00009	74 13		 je	 SHORT $LN3@RenderBack
  0000b	0f 1f 44 00 00	 npad	 5
$LL25@RenderBack:

; 37   : 		elem.second->RenderBackground();

  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 ?RenderBackground@CRenderTarget@@QBEXXZ ; CRenderTarget::RenderBackground
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 73   :         return _Ptr == _Right._Ptr;

  0001a	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 36   : 	for (const auto& elem : m_renderTargets)

  0001c	75 f2		 jne	 SHORT $LL25@RenderBack
$LN3@RenderBack:
  0001e	5f		 pop	 edi

; 38   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?RenderBackgrounds@CRenderTargetManager@@QAEXXZ ENDP	; CRenderTargetManager::RenderBackgrounds
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?UpdateModels@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?UpdateModels@CRenderTargetManager@@QAEXXZ PROC		; CRenderTargetManager::UpdateModels, COMDAT
; _this$ = ecx

; 29   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00002	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 37		 mov	 esi, DWORD PTR [edi]

; 73   :         return _Ptr == _Right._Ptr;

  00007	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 30   : 	for (auto& elem : m_renderTargets)

  00009	74 13		 je	 SHORT $LN3@UpdateMode
  0000b	0f 1f 44 00 00	 npad	 5
$LL25@UpdateMode:

; 31   : 		elem.second->UpdateModel();

  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 ?UpdateModel@CRenderTarget@@QAEXXZ ; CRenderTarget::UpdateModel
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 73   :         return _Ptr == _Right._Ptr;

  0001a	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 30   : 	for (auto& elem : m_renderTargets)

  0001c	75 f2		 jne	 SHORT $LL25@UpdateMode
$LN3@UpdateMode:
  0001e	5f		 pop	 edi

; 32   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?UpdateModels@CRenderTargetManager@@QAEXXZ ENDP		; CRenderTargetManager::UpdateModels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?DeformModels@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?DeformModels@CRenderTargetManager@@QAEXXZ PROC		; CRenderTargetManager::DeformModels, COMDAT
; _this$ = ecx

; 23   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00002	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 37		 mov	 esi, DWORD PTR [edi]

; 73   :         return _Ptr == _Right._Ptr;

  00007	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 24   : 	for (const auto& elem : m_renderTargets)

  00009	74 13		 je	 SHORT $LN3@DeformMode
  0000b	0f 1f 44 00 00	 npad	 5
$LL25@DeformMode:

; 25   : 		elem.second->DeformModel();

  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 ?DeformModel@CRenderTarget@@QBEXXZ ; CRenderTarget::DeformModel
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 73   :         return _Ptr == _Right._Ptr;

  0001a	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 24   : 	for (const auto& elem : m_renderTargets)

  0001c	75 f2		 jne	 SHORT $LL25@DeformMode
$LN3@DeformMode:
  0001e	5f		 pop	 edi

; 26   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?DeformModels@CRenderTargetManager@@QAEXXZ ENDP		; CRenderTargetManager::DeformModels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?Destroy@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CRenderTargetManager@@QAEXXZ PROC		; CRenderTargetManager::Destroy, COMDAT
; _this$ = ecx

; 19   : 	m_renderTargets.clear();

  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?clear@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::clear
?Destroy@CRenderTargetManager@@QAEXXZ ENDP		; CRenderTargetManager::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?ReleaseRenderTargetTextures@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?ReleaseRenderTargetTextures@CRenderTargetManager@@QAEXXZ PROC ; CRenderTargetManager::ReleaseRenderTargetTextures, COMDAT
; _this$ = ecx

; 53   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00002	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 37		 mov	 esi, DWORD PTR [edi]

; 73   :         return _Ptr == _Right._Ptr;

  00007	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 54   : 	for (const auto& elem : m_renderTargets)

  00009	74 13		 je	 SHORT $LN3@ReleaseRen
  0000b	0f 1f 44 00 00	 npad	 5
$LL25@ReleaseRen:

; 55   : 		elem.second->ReleaseTextures();

  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 ?ReleaseTextures@CRenderTarget@@QBEXXZ ; CRenderTarget::ReleaseTextures
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 73   :         return _Ptr == _Right._Ptr;

  0001a	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 54   : 	for (const auto& elem : m_renderTargets)

  0001c	75 f2		 jne	 SHORT $LL25@ReleaseRen
$LN3@ReleaseRen:
  0001e	5f		 pop	 edi

; 56   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?ReleaseRenderTargetTextures@CRenderTargetManager@@QAEXXZ ENDP ; CRenderTargetManager::ReleaseRenderTargetTextures
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?CreateRenderTargetTextures@CRenderTargetManager@@QAEXXZ
_TEXT	SEGMENT
?CreateRenderTargetTextures@CRenderTargetManager@@QAEXXZ PROC ; CRenderTargetManager::CreateRenderTargetTextures, COMDAT
; _this$ = ecx

; 47   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1099 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00002	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 37		 mov	 esi, DWORD PTR [edi]

; 73   :         return _Ptr == _Right._Ptr;

  00007	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 48   : 	for (const auto& elem : m_renderTargets)

  00009	74 13		 je	 SHORT $LN3@CreateRend
  0000b	0f 1f 44 00 00	 npad	 5
$LL25@CreateRend:

; 49   : 		elem.second->CreateTextures();

  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 ?CreateTextures@CRenderTarget@@QBEXXZ ; CRenderTarget::CreateTextures
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 51   :         _Ptr = _Ptr->_Next;

  00018	8b 36		 mov	 esi, DWORD PTR [esi]

; 73   :         return _Ptr == _Right._Ptr;

  0001a	3b f7		 cmp	 esi, edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 48   : 	for (const auto& elem : m_renderTargets)

  0001c	75 f2		 jne	 SHORT $LL25@CreateRend
$LN3@CreateRend:
  0001e	5f		 pop	 edi

; 50   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?CreateRenderTargetTextures@CRenderTargetManager@@QAEXXZ ENDP ; CRenderTargetManager::CreateRenderTargetTextures
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z
_TEXT	SEGMENT
$T2 = -32						; size = 8
$T3 = -24						; size = 8
$T4 = -24						; size = 8
$T5 = -20						; size = 4
$T6 = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 1
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z PROC ; CRenderTargetManager::CreateRenderTarget, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx
  0002b	33 d2		 xor	 edx, edx
  0002d	89 55 ec	 mov	 DWORD PTR $T6[ebp], edx

; 60   : 	if (index < 1 || GetRenderTarget(index))

  00030	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00033	3c 01		 cmp	 al, 1
  00035	72 18		 jb	 SHORT $LN4@CreateRend
  00037	50		 push	 eax
  00038	8d 45 e8	 lea	 eax, DWORD PTR $T4[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?GetRenderTarget@CRenderTargetManager@@QAE?AV?$shared_ptr@VCRenderTarget@@@std@@E@Z ; CRenderTargetManager::GetRenderTarget
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	83 38 00	 cmp	 DWORD PTR [eax], 0
  00049	75 04		 jne	 SHORT $LN4@CreateRend
  0004b	32 db		 xor	 bl, bl
  0004d	eb 02		 jmp	 SHORT $LN5@CreateRend
$LN4@CreateRend:
  0004f	b3 01		 mov	 bl, 1
$LN5@CreateRend:
  00051	83 cf ff	 or	 edi, -1
  00054	f6 c2 01	 test	 dl, 1
  00057	74 26		 je	 SHORT $LN21@CreateRend
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  00059	8b 75 ec	 mov	 esi, DWORD PTR $T4[ebp+4]
  0005c	85 f6		 test	 esi, esi
  0005e	74 1f		 je	 SHORT $LN21@CreateRend

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  00060	8b c7		 mov	 eax, edi
  00062	f0 0f c1 46 04	 lock	  xadd	 DWORD PTR [esi+4], eax
  00067	75 16		 jne	 SHORT $LN21@CreateRend

; 1106 :             _Destroy();

  00069	8b 06		 mov	 eax, DWORD PTR [esi]
  0006b	8b ce		 mov	 ecx, esi
  0006d	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  0006f	8b c7		 mov	 eax, edi
  00071	f0 0f c1 46 08	 lock	  xadd	 DWORD PTR [esi+8], eax
  00076	75 07		 jne	 SHORT $LN21@CreateRend

; 1113 :             _Delete_this();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b ce		 mov	 ecx, esi
  0007c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN21@CreateRend:
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 60   : 	if (index < 1 || GetRenderTarget(index))

  0007f	84 db		 test	 bl, bl
  00081	74 16		 je	 SHORT $LN2@CreateRend

; 61   : 		return false;

  00083	32 c0		 xor	 al, al

; 65   : }

  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
$LN2@CreateRend:
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 2726 :     const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);

  00099	6a 30		 push	 48			; 00000030H
  0009b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a0	8b f0		 mov	 esi, eax
  000a2	83 c4 04	 add	 esp, 4
  000a5	89 75 ec	 mov	 DWORD PTR $T5[ebp], esi
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000af	85 f6		 test	 esi, esi
  000b1	74 32		 je	 SHORT $LN25@CreateRend
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility

; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  000b3	ff 75 10	 push	 DWORD PTR _height$[ebp]
  000b6	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 2014 :             _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);

  000b9	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility

; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  000bc	ff 75 0c	 push	 DWORD PTR _width$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 2006 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

  000bf	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  000c3	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1065 :     _Atomic_counter_t _Uses  = 1;

  000ca	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1

; 1066 :     _Atomic_counter_t _Weaks = 1;

  000d1	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1

; 2006 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

  000d8	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$_Ref_count_obj2@VCRenderTarget@@@std@@6B@
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xutility

; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  000de	e8 00 00 00 00	 call	 ??0CRenderTarget@@QAE@KK@Z ; CRenderTarget::CRenderTarget
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 2726 :     const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);

  000e3	eb 02		 jmp	 SHORT $LN26@CreateRend
$LN25@CreateRend:
  000e5	33 f6		 xor	 esi, esi
$LN26@CreateRend:

; 2727 :     shared_ptr<_Ty> _Ret;
; 2728 :     _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);

  000e7	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]

; 1771 :         this->_Rep = _Rx;

  000ea	89 75 ec	 mov	 DWORD PTR $T3[ebp+4], esi
  000ed	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 63   : 	m_renderTargets.emplace(index, std::make_shared<CRenderTarget>(width, height));

  000f0	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000f3	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  000f6	50		 push	 eax
  000f7	8d 45 08	 lea	 eax, DWORD PTR _index$[ebp]
  000fa	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00101	50		 push	 eax
  00102	8d 45 e0	 lea	 eax, DWORD PTR $T2[ebp]
  00105	83 c1 04	 add	 ecx, 4
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ??$emplace@ABEV?$shared_ptr@VCRenderTarget@@@std@@@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@_N@1@ABE$$QAV?$shared_ptr@VCRenderTarget@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::emplace<unsigned char const &,std::shared_ptr<CRenderTarget> >
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1330 :         if (_Rep) {

  0010e	8b 75 ec	 mov	 esi, DWORD PTR $T3[ebp+4]
  00111	85 f6		 test	 esi, esi
  00113	74 1e		 je	 SHORT $LN51@CreateRend

; 1105 :         if (_MT_DECR(_Uses) == 0) {

  00115	8b c7		 mov	 eax, edi
  00117	f0 0f c1 46 04	 lock	  xadd	 DWORD PTR [esi+4], eax
  0011c	75 15		 jne	 SHORT $LN51@CreateRend

; 1106 :             _Destroy();

  0011e	8b 06		 mov	 eax, DWORD PTR [esi]
  00120	8b ce		 mov	 ecx, esi
  00122	ff 10		 call	 DWORD PTR [eax]

; 1112 :         if (_MT_DECR(_Weaks) == 0) {

  00124	f0 0f c1 7e 08	 lock	  xadd	 DWORD PTR [esi+8], edi
  00129	4f		 dec	 edi
  0012a	75 07		 jne	 SHORT $LN51@CreateRend

; 1113 :             _Delete_this();

  0012c	8b 06		 mov	 eax, DWORD PTR [esi]
  0012e	8b ce		 mov	 ecx, esi
  00130	ff 50 04	 call	 DWORD PTR [eax+4]
$LN51@CreateRend:
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 64   : 	return true;

  00133	b0 01		 mov	 al, 1

; 65   : }

  00135	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00138	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013f	59		 pop	 ecx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z$2:
  00000	6a 30		 push	 48			; 00000030H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z$1:
  0000f	8d 4d e8	 lea	 ecx, DWORD PTR $T3[ebp]
  00012	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VCRenderTarget@@@std@@QAE@XZ ; std::shared_ptr<CRenderTarget>::~shared_ptr<CRenderTarget>
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
__ehhandler$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z:
  0001c	90		 npad	 1
  0001d	90		 npad	 1
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateRenderTarget@CRenderTargetManager@@QAE_NEHH@Z ENDP ; CRenderTargetManager::CreateRenderTarget
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ?GetRenderTarget@CRenderTargetManager@@QAE?AV?$shared_ptr@VCRenderTarget@@@std@@E@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_index$ = 12						; size = 1
?GetRenderTarget@CRenderTargetManager@@QAE?AV?$shared_ptr@VCRenderTarget@@@std@@E@Z PROC ; CRenderTargetManager::GetRenderTarget, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  00006	8d 45 0c	 lea	 eax, DWORD PTR _index$[ebp]
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 68   : {

  00009	56		 push	 esi
  0000a	57		 push	 edi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  0000b	50		 push	 eax
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 68   : {

  0000c	8b f1		 mov	 esi, ecx
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\type_traits

; 2162 :         return _Hash_representation(_Keyval);

  0000e	e8 00 00 00 00	 call	 ??$_Hash_representation@E@std@@YAIABE@Z ; std::_Hash_representation<unsigned char>
  00013	83 c4 04	 add	 esp, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 1162 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

  00016	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00019	50		 push	 eax
  0001a	8d 45 0c	 lea	 eax, DWORD PTR _index$[ebp]
  0001d	50		 push	 eax
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$_Find_last@E@?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@PAX@std@@@1@ABEI@Z ; std::_Hash<std::_Umap_traits<unsigned char,std::shared_ptr<CRenderTarget>,std::_Uhash_compare<unsigned char,std::hash<unsigned char>,std::equal_to<unsigned char> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > >,0> >::_Find_last<unsigned char>
  00027	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1163 :             if (_Target) {

  0002a	85 c9		 test	 ecx, ecx
  0002c	75 03		 jne	 SHORT $LN14@GetRenderT

; 1164 :                 return _Target;
; 1165 :             }
; 1166 : 
; 1167 :             return _List._Mypair._Myval2._Myhead;

  0002e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN14@GetRenderT:
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 70   : 	if (it != m_renderTargets.end())

  00031	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00034	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 70   : 	if (it != m_renderTargets.end())

  00039	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00046	74 16		 je	 SHORT $LN1@GetRenderT
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory

; 1324 :         if (_Rep) {

  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	85 d2		 test	 edx, edx
  0004d	74 07		 je	 SHORT $LN55@GetRenderT

; 1097 :         _MT_INCR(_Uses);

  0004f	f0 ff 42 04	 lock	  inc	 DWORD PTR [edx+4]
  00053	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
$LN55@GetRenderT:

; 1285 :         _Ptr = _Other._Ptr;

  00056	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00059	89 08		 mov	 DWORD PTR [eax], ecx

; 1286 :         _Rep = _Other._Rep;

  0005b	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN1@GetRenderT:
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 74   : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?GetRenderTarget@CRenderTargetManager@@QAE?AV?$shared_ptr@VCRenderTarget@@@std@@E@Z ENDP ; CRenderTargetManager::GetRenderTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Singleton.h
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ??1CRenderTargetManager@@UAE@XZ
_TEXT	SEGMENT
??1CRenderTargetManager@@UAE@XZ PROC			; CRenderTargetManager::~CRenderTargetManager, COMDAT
; _this$ = ecx

; 13   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CRenderTargetManager@@6B@

; 14   : 	Destroy();

  00009	e8 00 00 00 00	 call	 ?Destroy@CRenderTargetManager@@QAEXXZ ; CRenderTargetManager::Destroy

; 15   : }

  0000e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00011	e8 00 00 00 00	 call	 ??1?$_Hash@V?$_Umap_traits@EV?$shared_ptr@VCRenderTarget@@@std@@V?$_Uhash_compare@EU?$hash@E@std@@U?$equal_to@E@2@@2@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Singleton.h

; 19   : 	{

  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCRenderTargetManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0;

  0001c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A, 0 ; CSingleton<CRenderTargetManager>::ms_singleton
  00026	5e		 pop	 esi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 15   : }

  00027	c3		 ret	 0
??1CRenderTargetManager@@UAE@XZ ENDP			; CRenderTargetManager::~CRenderTargetManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Singleton.h
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\unordered_map
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp
;	COMDAT ??0CRenderTargetManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CRenderTargetManager@@QAE@XZ PROC			; CRenderTargetManager::CRenderTargetManager, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CRenderTargetManager@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A, edi ; CSingleton<CRenderTargetManager>::ms_singleton
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 9    : {

  00032	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00035	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CRenderTargetManager@@6B@
  0003b	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\unordered_map

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

  0003e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00044	6a 14		 push	 20			; 00000014H
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 9    : {

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 352  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  0004d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00054	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	83 c4 04	 add	 esp, 4
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\list

; 1767 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00063	89 00		 mov	 DWORD PTR [eax], eax

; 1768 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  00065	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1769 :         _Mypair._Myval2._Myhead = _Newhead;

  00068	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 362  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

  0006b	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0006e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00074	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0007b	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xhash

; 365  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

  00082	ff 76 04	 push	 DWORD PTR [esi+4]
  00085	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00089	6a 10		 push	 16			; 00000010H
  0008b	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00092	c7 46 1c 08 00
	00 00		 mov	 DWORD PTR [esi+28], 8
  00099	c7 06 00 00 80
	3f		 mov	 DWORD PTR [esi], 1065353216 ; 3f800000H
  0009f	e8 00 00 00 00	 call	 ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::_Assign_grow
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterLib\RenderTargetManager.cpp

; 10   : }

  000a4	8b c7		 mov	 eax, edi
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b0	59		 pop	 ecx
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CRenderTargetManager@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCRenderTargetManager@@@@UAE@XZ ; CSingleton<CRenderTargetManager>::~CSingleton<CRenderTargetManager>
__unwindfunclet$??0CRenderTargetManager@@QAE@XZ$3:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$list@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@V?$allocator@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >::~list<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> >,std::allocator<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > >
__unwindfunclet$??0CRenderTargetManager@@QAE@XZ$4:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBEV?$shared_ptr@VCRenderTarget@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned char const ,std::shared_ptr<CRenderTarget> > > > > > >
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$??0CRenderTargetManager@@QAE@XZ:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CRenderTargetManager@@QAE@XZ
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CRenderTargetManager@@QAE@XZ ENDP			; CRenderTargetManager::CRenderTargetManager
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCRenderTargetManager@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCRenderTargetManager@@@@UAEPAXI@Z PROC ; CSingleton<CRenderTargetManager>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1

; 19   : 	{

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCRenderTargetManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0;

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A, 0 ; CSingleton<CRenderTargetManager>::ms_singleton
  0001a	74 0b		 je	 SHORT $LN6@scalar
  0001c	6a 04		 push	 4
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CSingleton@VCRenderTargetManager@@@@UAEPAXI@Z ENDP ; CSingleton<CRenderTargetManager>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\ALEXANDER\Desktop\Cliente\COPY_FISH_WON_NEW\Binario\Client\EterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCRenderTargetManager@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCRenderTargetManager@@@@UAE@XZ PROC	; CSingleton<CRenderTargetManager>::~CSingleton<CRenderTargetManager>, COMDAT
; _this$ = ecx

; 19   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCRenderTargetManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0;

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCRenderTargetManager@@@@0PAVCRenderTargetManager@@A, 0 ; CSingleton<CRenderTargetManager>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCRenderTargetManager@@@@UAE@XZ ENDP	; CSingleton<CRenderTargetManager>::~CSingleton<CRenderTargetManager>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT
; _this$ = ecx

; 1122 :         return nullptr;

  00000	33 c0		 xor	 eax, eax

; 1123 :     }

  00002	c2 04 00	 ret	 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\memory
;	COMDAT ??1_Ref_count_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Ref_count_base@std@@UAE@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT
; _this$ = ecx

; 1075 :     virtual ~_Ref_count_base() noexcept {} // TRANSITION, should be non-virtual

  00000	c2 00 00	 ret	 0
??1_Ref_count_base@std@@UAE@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 127  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 79   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 131  :         _Throw_bad_array_new_length(); // add overflow
; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 79   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 315  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 316  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\visual studio 2019\visual studio 2019\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
